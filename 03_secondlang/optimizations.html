<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>AST Optimizations (Visitor Pattern) - Create Your Own Programming Language with Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">
        <link rel="stylesheet" href="../theme/highlight.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Create Your Own Programming Language with Rust</h1>

                    <div class="right-buttons">
                        <a href="https://github.com/ehsanmok/create-your-own-lang-with-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ast-optimizations"><a class="header" href="#ast-optimizations">AST Optimizations</a></h1>
<p>Before we generate <a href="./codegen.html">LLVM code</a>, we can make the AST <em>better</em>. By “better”, we mean simpler expressions that do the same thing. For example, <code>1 + 2 * 3</code> can become just <code>7</code>. This is called <strong><a href="https://en.wikipedia.org/wiki/Optimizing_compiler">optimization</a></strong>.</p>
<p>In this chapter, we introduce the <strong><a href="https://en.wikipedia.org/wiki/Visitor_pattern">visitor pattern</a></strong>, a classic technique for walking through and transforming ASTs.</p>
<h2 id="the-visitor-pattern"><a class="header" href="#the-visitor-pattern">The Visitor Pattern</a></h2>
<p>Imagine we want to add a new operation on our AST, like “pretty print” or “count variables” or “simplify expressions”. Without a good design, we would need to modify every AST node type:</p>
<pre><code class="language-rust ignore">// Bad: scattered across many files
impl Expr {
    fn pretty_print(&amp;self) { ... }
    fn count_variables(&amp;self) { ... }
    fn simplify(&amp;self) { ... }
}</code></pre>
<p>Every time we add a new operation, we touch every node. That gets messy.</p>
<p>The visitor pattern flips this around. Instead of adding methods to nodes, we create separate <em>visitor</em> objects:</p>
<pre><code class="language-rust ignore">struct PrettyPrinter;
impl ExprVisitor for PrettyPrinter { ... }

struct ConstantFolder;
impl ExprVisitor for ConstantFolder { ... }</code></pre>
<p>Each visitor is self-contained. Adding a new operation means adding a new visitor, not modifying existing code. This follows the <a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">open/closed principle</a>: open for extension, closed for modification.</p>
<h2 id="the-exprvisitor-trait"><a class="header" href="#the-exprvisitor-trait">The ExprVisitor Trait</a></h2>
<p>Our visitor trait provides a hook for each expression type:</p>
<pre><code class="language-rust ignore">/// Visitor trait for traversing typed expressions
///
/// Each visit method returns the transformed expression.
/// Default implementations traverse children recursively.
pub trait ExprVisitor {
    /// Visit any expression - dispatches to specific visit methods
    fn visit_expr(&amp;mut self, expr: &amp;TypedExpr) -&gt; TypedExpr {
        let new_expr = match &amp;expr.expr {
            Expr::Int(n) =&gt; self.visit_int(*n),
            Expr::Bool(b) =&gt; self.visit_bool(*b),
            Expr::Var(name) =&gt; self.visit_var(name),
            Expr::Unary { op, expr: inner } =&gt; self.visit_unary(*op, inner),
            Expr::Binary { op, left, right } =&gt; self.visit_binary(*op, left, right),
            Expr::Call { name, args } =&gt; self.visit_call(name, args),
            Expr::If {
                cond,
                then_branch,
                else_branch,
            } =&gt; self.visit_if(cond, then_branch, else_branch),
            Expr::While { cond, body } =&gt; self.visit_while(cond, body),
            Expr::Block(stmts) =&gt; self.visit_block(stmts),
        };
        TypedExpr {
            expr: new_expr,
            ty: expr.ty.clone(),
        }
    }

    fn visit_int(&amp;mut self, n: i64) -&gt; Expr {
        Expr::Int(n)
    }

    fn visit_bool(&amp;mut self, b: bool) -&gt; Expr {
        Expr::Bool(b)
    }

    fn visit_var(&amp;mut self, name: &amp;str) -&gt; Expr {
        Expr::Var(name.to_string())
    }

    fn visit_unary(&amp;mut self, op: UnaryOp, expr: &amp;TypedExpr) -&gt; Expr {
        let visited = self.visit_expr(expr);
        Expr::Unary {
            op,
            expr: Box::new(visited),
        }
    }

    fn visit_binary(&amp;mut self, op: BinaryOp, left: &amp;TypedExpr, right: &amp;TypedExpr) -&gt; Expr {
        let l = self.visit_expr(left);
        let r = self.visit_expr(right);
        Expr::Binary {
            op,
            left: Box::new(l),
            right: Box::new(r),
        }
    }

    fn visit_call(&amp;mut self, name: &amp;str, args: &amp;[TypedExpr]) -&gt; Expr {
        let visited_args: Vec&lt;TypedExpr&gt; = args.iter().map(|a| self.visit_expr(a)).collect();
        Expr::Call {
            name: name.to_string(),
            args: visited_args,
        }
    }

    fn visit_if(&amp;mut self, cond: &amp;TypedExpr, then_branch: &amp;[Stmt], else_branch: &amp;[Stmt]) -&gt; Expr {
        let visited_cond = self.visit_expr(cond);
        let visited_then: Vec&lt;Stmt&gt; = then_branch.iter().map(|s| self.visit_stmt(s)).collect();
        let visited_else: Vec&lt;Stmt&gt; = else_branch.iter().map(|s| self.visit_stmt(s)).collect();
        Expr::If {
            cond: Box::new(visited_cond),
            then_branch: visited_then,
            else_branch: visited_else,
        }
    }

    fn visit_while(&amp;mut self, cond: &amp;TypedExpr, body: &amp;[Stmt]) -&gt; Expr {
        let visited_cond = self.visit_expr(cond);
        let visited_body: Vec&lt;Stmt&gt; = body.iter().map(|s| self.visit_stmt(s)).collect();
        Expr::While {
            cond: Box::new(visited_cond),
            body: visited_body,
        }
    }

    fn visit_block(&amp;mut self, stmts: &amp;[Stmt]) -&gt; Expr {
        let visited: Vec&lt;Stmt&gt; = stmts.iter().map(|s| self.visit_stmt(s)).collect();
        Expr::Block(visited)
    }

    /// Visit a statement
    fn visit_stmt(&amp;mut self, stmt: &amp;Stmt) -&gt; Stmt {
        match stmt {
            Stmt::Function {
                name,
                params,
                return_type,
                body,
            } =&gt; {
                let visited_body: Vec&lt;Stmt&gt; = body.iter().map(|s| self.visit_stmt(s)).collect();
                Stmt::Function {
                    name: name.clone(),
                    params: params.clone(),
                    return_type: return_type.clone(),
                    body: visited_body,
                }
            }
            Stmt::Return(expr) =&gt; Stmt::Return(self.visit_expr(expr)),
            Stmt::Assignment {
                name,
                type_ann,
                value,
            } =&gt; Stmt::Assignment {
                name: name.clone(),
                type_ann: type_ann.clone(),
                value: self.visit_expr(value),
            },
            Stmt::Expr(expr) =&gt; Stmt::Expr(self.visit_expr(expr)),
        }
    }
}</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/secondlang/src/visitor.rs">secondlang/src/visitor.rs</a></p>
<p>Let us understand how this works:</p>
<ol>
<li>
<p><code>visit_expr</code> is the entry point. It looks at the expression type and calls the appropriate visitor method.</p>
</li>
<li>
<p>Each <code>visit_*</code> method has a <em>default implementation</em> that just recurses into children. For example, <code>visit_binary</code> visits left and right, then rebuilds the binary expression.</p>
</li>
<li>
<p>To customize behavior, we override the methods we care about. For constant folding, we override <code>visit_binary</code> to check if both operands are constants.</p>
</li>
</ol>
<p>This is sometimes called a <strong>tree walk</strong> or <strong><a href="https://en.wikipedia.org/wiki/Tree_traversal">tree traversal</a></strong>.</p>
<h2 id="optimization-1-constant-folding"><a class="header" href="#optimization-1-constant-folding">Optimization 1: Constant Folding</a></h2>
<p><strong><a href="https://en.wikipedia.org/wiki/Constant_folding">Constant folding</a></strong> evaluates expressions where all values are known at compile time:</p>
<p>$$
\begin{aligned}
1 + 2 \times 3 &amp;\Rightarrow 7 \\
5 &lt; 10 &amp;\Rightarrow \text{true} \\
-(-42) &amp;\Rightarrow 42
\end{aligned}
$$</p>
<p>Why wait until runtime to compute <code>1 + 2</code> when we can do it now?</p>
<p>Here is the pseudocode:</p>
<pre><code class="language-text">FUNCTION constant_fold(expr):
   case expr of:
   | Binary(op, left, right):
       folded_left = constant_fold(left)
       folded_right = constant_fold(right)

       if both folded_left and folded_right are constants:
           compute the result at compile time
           return the constant result
       else:
           return Binary(op, folded_left, folded_right)

   | Unary(op, inner):
       folded = constant_fold(inner)
       if folded is a constant:
           compute result
           return constant
       else:
           return Unary(op, folded)

   | other:
       return expr  # cannot fold
</code></pre>
<p>And the implementation:</p>
<pre><code class="language-rust ignore">/// Folds constant expressions: `1 + 2` becomes `3`
///
/// This is a simple optimization that evaluates expressions
/// where all operands are known at compile time.
pub struct ConstantFolder;

impl ConstantFolder {
    pub fn new() -&gt; Self {
        ConstantFolder
    }

    pub fn fold_program(stmts: &amp;[Stmt]) -&gt; Vec&lt;Stmt&gt; {
        let mut folder = ConstantFolder::new();
        stmts.iter().map(|s| folder.visit_stmt(s)).collect()
    }
}

impl Default for ConstantFolder {
    fn default() -&gt; Self {
        Self::new()
    }
}

impl ExprVisitor for ConstantFolder {
    fn visit_binary(&amp;mut self, op: BinaryOp, left: &amp;TypedExpr, right: &amp;TypedExpr) -&gt; Expr {
        // First, recursively fold children
        let l = self.visit_expr(left);
        let r = self.visit_expr(right);

        // Try to fold if both are constants
        if let (Expr::Int(lv), Expr::Int(rv)) = (&amp;l.expr, &amp;r.expr) {
            let result = match op {
                BinaryOp::Add =&gt; Some(lv + rv),
                BinaryOp::Sub =&gt; Some(lv - rv),
                BinaryOp::Mul =&gt; Some(lv * rv),
                BinaryOp::Div if *rv != 0 =&gt; Some(lv / rv),
                BinaryOp::Mod if *rv != 0 =&gt; Some(lv % rv),
                _ =&gt; None,
            };
            if let Some(val) = result {
                return Expr::Int(val);
            }
        }

        // Try boolean constant folding for comparisons
        if let (Expr::Int(lv), Expr::Int(rv)) = (&amp;l.expr, &amp;r.expr) {
            let result = match op {
                BinaryOp::Lt =&gt; Some(*lv &lt; *rv),
                BinaryOp::Gt =&gt; Some(*lv &gt; *rv),
                BinaryOp::Le =&gt; Some(*lv &lt;= *rv),
                BinaryOp::Ge =&gt; Some(*lv &gt;= *rv),
                BinaryOp::Eq =&gt; Some(*lv == *rv),
                BinaryOp::Ne =&gt; Some(*lv != *rv),
                _ =&gt; None,
            };
            if let Some(val) = result {
                return Expr::Bool(val);
            }
        }

        // Can't fold, return as-is
        Expr::Binary {
            op,
            left: Box::new(l),
            right: Box::new(r),
        }
    }

    fn visit_unary(&amp;mut self, op: UnaryOp, expr: &amp;TypedExpr) -&gt; Expr {
        let e = self.visit_expr(expr);

        match (&amp;op, &amp;e.expr) {
            (UnaryOp::Neg, Expr::Int(n)) =&gt; Expr::Int(-n),
            (UnaryOp::Not, Expr::Bool(b)) =&gt; Expr::Bool(!b),
            _ =&gt; Expr::Unary {
                op,
                expr: Box::new(e),
            },
        }
    }
}</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/secondlang/src/visitor.rs">secondlang/src/visitor.rs</a></p>
<p>Let us trace through <code>1 + 2 * 3</code>:</p>
<ol>
<li>Visit outer <code>+</code> expression</li>
<li>Recursively visit left (<code>1</code>) → returns <code>Int(1)</code></li>
<li>Recursively visit right (<code>2 * 3</code>) → visits <code>*</code>, finds <code>Int(2)</code> and <code>Int(3)</code>, returns <code>Int(6)</code></li>
<li>Back at <code>+</code>: left is <code>Int(1)</code>, right is <code>Int(6)</code> → return <code>Int(7)</code></li>
</ol>
<p>The whole expression becomes just <code>7</code>.</p>
<h2 id="optimization-2-algebraic-simplification"><a class="header" href="#optimization-2-algebraic-simplification">Optimization 2: Algebraic Simplification</a></h2>
<p><strong><a href="https://en.wikipedia.org/wiki/Algebraic_simplification">Algebraic simplification</a></strong> (also called <strong>strength reduction</strong>) applies mathematical identities:</p>
<div class="table-wrapper"><table><thead><tr><th>Expression</th><th>Simplified</th><th>Identity Applied</th></tr></thead><tbody>
<tr><td><code>x + 0</code></td><td><code>x</code></td><td>Additive identity</td></tr>
<tr><td><code>x - 0</code></td><td><code>x</code></td><td>Additive identity</td></tr>
<tr><td><code>x * 0</code></td><td><code>0</code></td><td>Zero property</td></tr>
<tr><td><code>x * 1</code></td><td><code>x</code></td><td>Multiplicative identity</td></tr>
<tr><td><code>x / 1</code></td><td><code>x</code></td><td>Multiplicative identity</td></tr>
<tr><td><code>0 + x</code></td><td><code>x</code></td><td>Commutativity + identity</td></tr>
<tr><td><code>1 * x</code></td><td><code>x</code></td><td>Commutativity + identity</td></tr>
</tbody></table>
</div>
<p>These transformations are always valid and can save runtime computation.</p>
<p>Pseudocode:</p>
<pre><code class="language-text">FUNCTION simplify(expr):
   case expr of:
   | Binary(Add, x, Int(0)): return simplify(x)
   | Binary(Add, Int(0), x): return simplify(x)
   | Binary(Mul, x, Int(1)): return simplify(x)
   | Binary(Mul, Int(1), x): return simplify(x)
   | Binary(Mul, _, Int(0)): return Int(0)
   | Binary(Mul, Int(0), _): return Int(0)
   | ... # other cases
   | Binary(op, left, right):
       return Binary(op, simplify(left), simplify(right))
   | other:
       return expr
</code></pre>
<p>Implementation:</p>
<pre><code class="language-rust ignore">/// Applies algebraic simplifications:
/// - `x + 0` → `x`
/// - `x - 0` → `x`
/// - `x * 0` → `0`
/// - `x * 1` → `x`
/// - `x / 1` → `x`
/// - `0 + x` → `x`
/// - `1 * x` → `x`
/// - `0 * x` → `0`
pub struct AlgebraicSimplifier;

impl AlgebraicSimplifier {
    pub fn new() -&gt; Self {
        AlgebraicSimplifier
    }

    pub fn simplify_program(stmts: &amp;[Stmt]) -&gt; Vec&lt;Stmt&gt; {
        let mut simplifier = AlgebraicSimplifier::new();
        stmts.iter().map(|s| simplifier.visit_stmt(s)).collect()
    }
}

impl Default for AlgebraicSimplifier {
    fn default() -&gt; Self {
        Self::new()
    }
}

impl ExprVisitor for AlgebraicSimplifier {
    fn visit_binary(&amp;mut self, op: BinaryOp, left: &amp;TypedExpr, right: &amp;TypedExpr) -&gt; Expr {
        // First, recursively simplify children
        let l = self.visit_expr(left);
        let r = self.visit_expr(right);

        // Apply algebraic identities
        match (&amp;op, &amp;l.expr, &amp;r.expr) {
            // x + 0 = x
            (BinaryOp::Add, _, Expr::Int(0)) =&gt; return l.expr,
            // 0 + x = x
            (BinaryOp::Add, Expr::Int(0), _) =&gt; return r.expr,
            // x - 0 = x
            (BinaryOp::Sub, _, Expr::Int(0)) =&gt; return l.expr,
            // x * 0 = 0
            (BinaryOp::Mul, _, Expr::Int(0)) =&gt; return Expr::Int(0),
            // 0 * x = 0
            (BinaryOp::Mul, Expr::Int(0), _) =&gt; return Expr::Int(0),
            // x * 1 = x
            (BinaryOp::Mul, _, Expr::Int(1)) =&gt; return l.expr,
            // 1 * x = x
            (BinaryOp::Mul, Expr::Int(1), _) =&gt; return r.expr,
            // x / 1 = x
            (BinaryOp::Div, _, Expr::Int(1)) =&gt; return l.expr,
            _ =&gt; {}
        }

        Expr::Binary {
            op,
            left: Box::new(l),
            right: Box::new(r),
        }
    }
}</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/secondlang/src/visitor.rs">secondlang/src/visitor.rs</a></p>
<h2 id="chaining-optimizations"><a class="header" href="#chaining-optimizations">Chaining Optimizations</a></h2>
<p>Multiple optimization passes can be chained. This is called a <strong><a href="https://en.wikipedia.org/wiki/Multi-pass_compiler">pass pipeline</a></strong>:</p>
<pre><code class="language-rust ignore">pub fn optimize_program(program: &amp;Program) -&gt; Program {
    // First: fold constants
    let program = ConstantFolder::fold_program(&amp;program);
    // Then: simplify algebra
    AlgebraicSimplifier::simplify_program(&amp;program)
}</code></pre>
<p>Consider <code>x * (1 + 0)</code>:</p>
<ol>
<li>After constant folding: <code>x * 1</code> (because <code>1 + 0 = 1</code>)</li>
<li>After algebraic simplification: <code>x</code> (because <code>x * 1 = x</code>)</li>
</ol>
<p>Two passes, significant simplification. The order matters - constant folding first creates opportunities for algebraic simplification.</p>
<h2 id="why-bother"><a class="header" href="#why-bother">Why Bother?</a></h2>
<p>You might wonder: “LLVM will optimize this anyway. Why do it ourselves?”</p>
<p>Good question. LLVM <em>will</em> do these optimizations. But:</p>
<ol>
<li>
<p><strong>Learning</strong>: Implementing optimizations helps you understand how compilers work. These are the same techniques used in production compilers.</p>
</li>
<li>
<p><strong>Simplicity</strong>: Simpler AST means simpler code generation. Less can go wrong.</p>
</li>
<li>
<p><strong>Debug output</strong>: When you print the AST for debugging, optimized code is easier to read.</p>
</li>
<li>
<p><strong>Specialized optimizations</strong>: You might know things about your language that LLVM does not. Custom optimizations can exploit that knowledge.</p>
</li>
<li>
<p><strong>Compile time</strong>: Simpler AST means less work for LLVM, which means faster compilation.</p>
</li>
</ol>
<h2 id="other-common-optimizations"><a class="header" href="#other-common-optimizations">Other Common Optimizations</a></h2>
<p>Production compilers do many more optimizations:</p>
<div class="table-wrapper"><table><thead><tr><th>Optimization</th><th>What it does</th></tr></thead><tbody>
<tr><td><a href="https://en.wikipedia.org/wiki/Dead_code_elimination">Dead code elimination</a></td><td>Remove unreachable code</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Common_subexpression_elimination">Common subexpression elimination</a></td><td>Compute <code>x * y</code> once if used twice</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Loop_unrolling">Loop unrolling</a></td><td>Replace loops with repeated code</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Inline_expansion">Inlining</a></td><td>Replace function calls with function bodies</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Tail_call">Tail call optimization</a></td><td>Turn tail recursion into loops</td></tr>
</tbody></table>
</div>
<p>We leave these as exercises. The visitor pattern makes adding new optimizations straightforward.</p>
<h2 id="using-the-optimizations"><a class="header" href="#using-the-optimizations">Using the Optimizations</a></h2>
<p>Enable optimizations with the <code>-O</code> flag:</p>
<pre><code class="language-bash"># Without optimization
rustup run nightly cargo run -- --ir examples/fibonacci.sl

# With optimization
rustup run nightly cargo run -- --ir -O examples/fibonacci.sl
</code></pre>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<pre><code class="language-bash">rustup run nightly cargo test
</code></pre>
<p>In the next chapter, we look at what <a href="./ir.html">LLVM IR</a> looks like before we start generating it.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../03_secondlang/inference.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../03_secondlang/ir.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../03_secondlang/inference.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../03_secondlang/ir.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/force-theme.js"></script>



    </div>
    </body>
</html>
