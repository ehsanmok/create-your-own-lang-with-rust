// Secondlang Grammar - A typed Python-like language
// Same syntax as Firstlang, but with type annotations

WHITESPACE = _{ " " | "\t" | NEWLINE }
COMMENT = _{ "#" ~ (!NEWLINE ~ ANY)* }

// Keywords
KEYWORD = @{ "def" | "if" | "else" | "while" | "true" | "false" | "return" | "int" | "bool" }

// Identifiers (variable/function names)
Identifier = @{ !KEYWORD ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// Types
Type = { IntType | BoolType }
IntType = { "int" }
BoolType = { "bool" }

// Program is a sequence of statements/expressions
Program = _{ SOI ~ Stmt* ~ EOI }

// Statements
Stmt = { Function | SimpleStmt }
SimpleStmt = _{ (Return | Assignment | Expr) }

// Function definition with types: def name(x: int, y: int) -> int { body }
Function = { "def" ~ Identifier ~ "(" ~ TypedParams? ~ ")" ~ ReturnType? ~ Block }
TypedParams = _{ TypedParam ~ ("," ~ TypedParam)* }
TypedParam = { Identifier ~ ":" ~ Type }
ReturnType = { "->" ~ Type }

// Block: { statements }
Block = { "{" ~ Stmt* ~ "}" }

// Return statement
Return = { "return" ~ Expr }

// Assignment with optional type: x: int = 10  or  x = 10
Assignment = { Identifier ~ (":" ~ Type)? ~ "=" ~ Expr }

// Expressions (ordered by precedence - lowest to highest)
Expr = { Conditional | WhileLoop | Comparison }

// if (cond) { ... } else { ... }
Conditional = { "if" ~ "(" ~ Expr ~ ")" ~ Block ~ "else" ~ Block }

// while (cond) { ... }
WhileLoop = { "while" ~ "(" ~ Expr ~ ")" ~ Block }

// Comparison operators
Comparison = { Additive ~ (CompOp ~ Additive)* }
CompOp = { "<=" | ">=" | "<" | ">" | "==" | "!=" }

// Addition/Subtraction
Additive = { Multiplicative ~ (AddOp ~ Multiplicative)* }
AddOp = { "+" | "-" }

// Multiplication/Division
Multiplicative = { Unary ~ (MulOp ~ Unary)* }
MulOp = { "*" | "/" | "%" }

// Unary operators
Unary = { UnaryOp ~ Unary | Call }
UnaryOp = { "-" | "!" }

// Function call: name(args)
Call = { Primary ~ CallArgs* }
CallArgs = { "(" ~ Args? ~ ")" }
Args = _{ Expr ~ ("," ~ Expr)* }

// Primary expressions
Primary = _{ Literal | Identifier | "(" ~ Expr ~ ")" }

// Literals
Literal = { Bool | Int }
Int = @{ ASCII_DIGIT+ }
Bool = @{ "true" | "false" }

