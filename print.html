<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Create Your Own Programming Language with Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">
        <link rel="stylesheet" href="theme/highlight.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Create Your Own Programming Language with Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ehsanmok/create-your-own-lang-with-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div class="license-notice">
<p><em>Materials in this book are distributed under the terms of <a href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/LICENSE">Creative Commons BY-NC-SA 4.0</a></em></p>
<img alt="license" src="./img/by-nc-sa.png">
</div>
<p>This book assumes some basic knowledge of the Rust language. Please take a look at the official <a href="https://doc.rust-lang.org/book/">Rust book</a>.</p>
<p>The accompanying code and materials for this book are available on <a href="https://github.com/ehsanmok/create-your-own-lang-with-rust">GitHub</a>. To follow along, make sure you have</p>
<ul>
<li>
<p><a href="https://www.rust-lang.org/tools/install">Rust toolchain installed</a> (stable 1.70+)</p>
</li>
<li>
<p>Cloned the repository</p>
<pre><code class="language-bash">git clone https://github.com/ehsanmok/create-your-own-lang-with-rust
</code></pre>
<p>Then navigate to the project directory:</p>
<pre><code class="language-bash">cd create-your-own-lang-with-rust
</code></pre>
</li>
</ul>
<p><strong>What works with stable Rust:</strong></p>
<ul>
<li><strong>Calculator</strong> (interpreter and VM modes) - <code>cargo run</code></li>
<li><strong>Firstlang</strong> (interpreter) - <code>cargo run</code></li>
</ul>
<p><strong>What requires nightly Rust + LLVM:</strong></p>
<ul>
<li><strong>Calculator JIT</strong> - <code>rustup run nightly cargo run --features jit</code></li>
<li><strong>Secondlang</strong> (compiled to native code) - <code>rustup run nightly cargo run</code></li>
</ul>
<p>To use LLVM features:</p>
<ul>
<li>Install nightly: <code>rustup toolchain install nightly</code></li>
<li>Install LLVM: macOS (<code>brew install llvm</code>), Debian/Ubuntu (<a href="https://apt.llvm.org/">apt.llvm.org</a>)</li>
<li>Check your version: <code>llvm-config --version</code></li>
<li>Update <code>Cargo.toml</code> to match: LLVM 20.x uses <code>llvm20-1</code>, LLVM 19.x uses <code>llvm19-1</code>, LLVM 18.x uses <code>llvm18-1</code></li>
</ul>
<h2 id="motivations-and-goals"><a class="header" href="#motivations-and-goals">Motivations and Goals</a></h2>
<p>This book arises from my frustration of not finding modern, clear, and concise teaching materials that are readily accessible to beginners like me who want to learn how to create their own programming language.</p>
<p>The following are my guidelines:</p>
<blockquote>
<p>“If you don’t know how <em>compilers</em> work, then you don’t know how computers work” <sup><a href="http://steve-yegge.blogspot.com/2007/06/rich-programmer-food.html?">1</a></sup></p>
</blockquote>
<blockquote>
<p>“If you can’t explain something in simple terms, you don’t understand it” <sup><a href="https://skeptics.stackexchange.com/questions/8742/did-einstein-say-if-you-cant-explain-it-simply-you-dont-understand-it-well-en">2</a></sup></p>
</blockquote>
<p><span style="font-family:Trebuchet MS">Pedagogically, one of the most effective methods of teaching is co-creating interactively. Introducing the core aspects around the <em>simplest example</em> (here, our calculator language) helps a lot to build knowledge and confidence. For that, we will use mature technologies instead of spending tons of time partially reinventing the wheel and boring the reader.</span></p>
<h2 id="learning-progression"><a class="header" href="#learning-progression">Learning Progression</a></h2>
<p>We build three languages, each building on concepts from the previous:</p>
<div class="table-wrapper"><table><thead><tr><th>Language</th><th>Grammar</th><th>New Concepts</th><th>Execution</th></tr></thead><tbody>
<tr><td><strong>Calculator</strong></td><td>18 lines</td><td>PEG basics, AST, operators</td><td>Interpreter, VM, JIT</td></tr>
<tr><td><strong>Firstlang</strong></td><td>70 lines</td><td>Variables, functions, control flow, recursion</td><td>Tree-walking interpreter</td></tr>
<tr><td><strong>Secondlang</strong></td><td>77 lines</td><td>Types, type inference, optimization passes</td><td>LLVM JIT compilation</td></tr>
</tbody></table>
</div>
<h3 id="part-i-calculator"><a class="header" href="#part-i-calculator">Part I: Calculator</a></h3>
<p>We start with the <em>simplest possible language</em>: integer arithmetic with <code>+</code> and <code>-</code>. The grammar fits in 18 lines:</p>
<pre><code class="language-text">Program = _{ SOI ~ Expr ~ EOF }
Expr = { UnaryExpr | BinaryExpr | Term }
Term = _{Int | "(" ~ Expr ~ ")" }
...
</code></pre>
<p>This minimal language lets us focus on the fundamentals without distraction: what is a grammar? How does pest generate a parser? What is an AST? We also explore <em>three different backends</em> (interpreter, bytecode VM, JIT) to show that the same AST can be executed in multiple ways.</p>
<h3 id="part-ii-firstlang"><a class="header" href="#part-ii-firstlang">Part II: Firstlang</a></h3>
<p>With the basics understood, we add the features that make a <em>real</em> programming language. The grammar grows to 70 lines, adding:</p>
<pre><code class="language-text">// New: Statements instead of just expressions
Stmt = { Function | Return | Assignment | Expr }

// New: Functions with parameters
Function = { "def" ~ Identifier ~ "(" ~ Params? ~ ")" ~ Block }

// New: Control flow
Conditional = { "if" ~ "(" ~ Expr ~ ")" ~ Block ~ "else" ~ Block }
WhileLoop = { "while" ~ "(" ~ Expr ~ ")" ~ Block }
</code></pre>
<p>We focus on a single backend (tree-walking interpreter) to deeply understand scoping, call stacks, and recursion. The culminating example is computing Fibonacci recursively.</p>
<h3 id="part-iii-secondlang"><a class="header" href="#part-iii-secondlang">Part III: Secondlang</a></h3>
<p>Finally, we add <em>static types</em> and compile to native code. The grammar changes are minimal (just 7 more lines), but the compiler grows significantly:</p>
<pre><code class="language-text">// New: Type annotations
Type = { IntType | BoolType }
TypedParam = { Identifier ~ ":" ~ Type }
ReturnType = { "-&gt;" ~ Type }

// Modified: Functions now have types
Function = { "def" ~ Identifier ~ "(" ~ TypedParams? ~ ")" ~ ReturnType? ~ Block }
</code></pre>
<p>This demonstrates a key insight: types are primarily a <em>semantic</em> addition, not a syntactic one. The grammar changes are small, but we need new compiler phases (type checking, type inference) and can now generate efficient native code via LLVM.</p>
<h2 id="outline"><a class="header" href="#outline">Outline</a></h2>
<ul>
<li><a href="./crash_course.html">Crash Course on Computing</a> where we briefly set up definitions and foundations</li>
<li><a href="./01_calculator/calc_intro.html"><strong>Calculator</strong></a>: Our first language supporting simple integer addition and subtraction. We use <a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">PEG</a> to define our grammar, <a href="https://pest.rs/">pest</a> to generate the parser, and explore AST interpretation, JIT compilation with <a href="https://github.com/TheDan64/inkwell">inkwell</a>, and a bytecode VM</li>
<li><a href="./02_firstlang/intro.html"><strong>Firstlang</strong></a>: An interpreted language with variables, functions, control flow, and recursion. We implement <a href="./02_firstlang/fibonacci.html">Fibonacci</a> as the culminating example</li>
<li><a href="./03_secondlang/intro.html"><strong>Secondlang</strong></a>: A statically typed language that compiles to native code via LLVM. We add <a href="./03_secondlang/annotations.html">type annotations</a>, <a href="./03_secondlang/inference.html">type inference</a>, AST <a href="./03_secondlang/optimizations.html">optimization passes</a> with the visitor pattern, and <a href="./03_secondlang/jit_fibonacci.html">JIT compilation</a></li>
</ul>
<h2 id="donation"><a class="header" href="#donation">Donation</a></h2>
<p>If you have found this book useful, please consider donating to any of the organizations below</p>
<ul>
<li><a href="https://childfoundation.org/">Child Foundation</a></li>
<li><a href="https://blacklivesmatter.com/">Black Lives Matter</a></li>
<li><a href="https://www.foodbankscanada.ca/">Food Bank of Canada</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>Here is a bird’s-eye view of a computer program execution</p>
<p align="center">
</br>
    <a href><img alt="compiler" src="./img/code-compiler-executor.svg"> </a>
</p>
<p>All these three components are intertwined together and learning their connections is crucial in understanding what makes <em>Computing</em> possible. Informally, a <em>language</em> is a structured text with syntax and semantics. A <em>Source Code</em> written in a programming language needs a translator/compiler of <em>some sort</em>, to translate it to <em>another</em> language/format. Then an executor of <em>some sort</em>, to execute/run the translated commands with the goal of matching the syntax (and semantics) to <em>some form</em> of output.</p>
<h2 id="elements-of-computing"><a class="header" href="#elements-of-computing">Elements of Computing</a></h2>
<h3 id="what-is-a-grammar"><a class="header" href="#what-is-a-grammar">What is a Grammar?</a></h3>
<p>A <strong><a href="https://en.wikipedia.org/wiki/Formal_grammar">formal grammar</a></strong> is a set of rules that define what makes valid code in a programming language. Think of it like the grammar of English: “The cat sat” is valid, but “Cat the sat” is not.</p>
<p>For programming languages, a grammar specifies:</p>
<ul>
<li><strong>What tokens are valid</strong> - keywords like <code>def</code>, <code>if</code>, <code>return</code>; operators like <code>+</code>, <code>-</code>, <code>*</code>; literals like <code>42</code>, <code>true</code></li>
<li><strong>How tokens can be combined</strong> - <code>1 + 2</code> is valid, <code>+ + 1</code> is not</li>
<li><strong>The structure of programs</strong> - functions contain statements, statements contain expressions</li>
</ul>
<p>We use <strong><a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">PEG (Parsing Expression Grammar)</a></strong> to define our grammars. PEG is a modern approach that is easier to learn than traditional techniques like <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">BNF</a> or parser generators like <a href="https://en.wikipedia.org/wiki/Yacc">yacc</a>/<a href="https://en.wikipedia.org/wiki/GNU_Bison">bison</a>.</p>
<h3 id="peg-and-pest-syntax"><a class="header" href="#peg-and-pest-syntax">PEG and pest Syntax</a></h3>
<p>We use <strong><a href="https://pest.rs">pest</a></strong>, a Rust library that generates <a href="https://en.wikipedia.org/wiki/Parsing">parsers</a> from PEG grammars. Here is a quick reference of pest syntax:</p>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Meaning</th><th>Example</th></tr></thead><tbody>
<tr><td><code>"text"</code></td><td>Match exact text</td><td><code>"def"</code> matches the keyword def</td></tr>
<tr><td><code>~</code></td><td>Sequence (then)</td><td><code>"if" ~ "(" ~ Expr ~ ")"</code> matches <code>if</code> followed by <code>(</code></td></tr>
<tr><td><code>|</code></td><td>Choice (or)</td><td><code>"true" | "false"</code> matches either</td></tr>
<tr><td><code>*</code></td><td>Zero or more (<a href="https://en.wikipedia.org/wiki/Kleene_star">Kleene star</a>)</td><td><code>Stmt*</code> matches any number of statements</td></tr>
<tr><td><code>+</code></td><td>One or more</td><td><code>ASCII_DIGIT+</code> matches one or more digits</td></tr>
<tr><td><code>?</code></td><td>Optional</td><td><code>ReturnType?</code> matches zero or one return type</td></tr>
<tr><td><code>{ }</code></td><td>Rule definition</td><td><code>Add = { "+" }</code> defines a rule</td></tr>
<tr><td><code>_{ }</code></td><td>Silent rule</td><td><code>_{ Expr }</code> matches but does not appear in AST</td></tr>
<tr><td><code>@{ }</code></td><td>Atomic rule</td><td><code>@{ ASCII_DIGIT+ }</code> matches as a single token</td></tr>
<tr><td><code>SOI</code></td><td>Start of input</td><td>Beginning of the source code</td></tr>
<tr><td><code>EOI</code></td><td>End of input</td><td>End of the source code</td></tr>
</tbody></table>
</div>
<p><strong>Silent rules</strong> (<code>_{ }</code>) are useful for grouping without cluttering the <a href="https://en.wikipedia.org/wiki/Parse_tree">parse tree</a>. For example, whitespace rules are typically silent.</p>
<p><strong>Atomic rules</strong> (<code>@{ }</code>) prevent whitespace from being inserted between parts. <code>@{ ASCII_DIGIT+ }</code> matches <code>123</code> as one token, not <code>1 2 3</code>.</p>
<p>A simple grammar example:</p>
<pre><code class="language-text">Program = _{ SOI ~ Expr ~ EOI }       // A program is an expression
Expr = { Int | "(" ~ Expr ~ ")" }     // An expression is an int or parenthesized expr
Int = @{ ASCII_DIGIT+ }               // An int is one or more digits (atomic)
WHITESPACE = _{ " " | "\t" | "\n" }   // Whitespace is silent (ignored)
</code></pre>
<p>This grammar accepts: <code>42</code>, <code>(42)</code>, <code>((42))</code>, etc.</p>
<p>We use this pest syntax throughout the book. See <a href="./01_calculator/grammar_lexer_parser.html">Calculator’s grammar</a> for a real example, <a href="./02_firstlang/syntax.html">Firstlang’s syntax</a> for a more complex grammar, and <a href="./03_secondlang/annotations.html">Secondlang’s type annotations</a> for adding types.</p>
<h3 id="instructions-and-the-machine-language"><a class="header" href="#instructions-and-the-machine-language">Instructions and the Machine Language</a></h3>
<p>If you want to create a “computer” from scratch, you need to start by defining an <em>abstract model</em> for your computer. This abstract model is also referred to as <strong><a href="https://en.wikipedia.org/wiki/Instruction_set_architecture">Instruction Set Architecture (ISA)</a></strong> (instruction set or simply <em>instructions</em>). A <a href="https://en.wikipedia.org/wiki/Central_processing_unit">CPU</a> is an <em>implementation</em> of such ISA. A standard ISA defines its basic elements such as <em>data types</em>, <em><a href="https://en.wikipedia.org/wiki/Processor_register">register</a></em> values, various hardware supports, I/O etc. and they all make up the  <em>lowest-level language</em> of computing which is the <strong><a href="https://en.wikipedia.org/wiki/Machine_code">Machine Language</a> Instructions.</strong></p>
<p>Instructions are comprised of <em>instruction code</em> (aka <em>operation code</em>, in short <strong><a href="https://en.wikipedia.org/wiki/Opcode">opcode</a></strong> or p-code) which are directly executed by the CPU. An opcode can either have operand(s) or no operand. For example, in an 8-bit machine where instructions are 8 bits, an opcode <em>load</em> might be defined by the 4 bits <strong>0011</strong> followed by the second 4 bits as operand with <strong>0101</strong>, making up the instruction <strong>00110101</strong> in Machine Language. The opcode for <em>incrementing by 1</em> of the previously loaded value could be defined by <strong>1000</strong> with no operand.</p>
<p>Since <em>opcodes are like atoms of computing</em>, they are presented in an opcode table. An example of that is the <a href="https://www.felixcloutier.com/x86/">x86 opcode reference</a>.</p>
<h3 id="assembly-language"><a class="header" href="#assembly-language">Assembly Language</a></h3>
<p>Since it’s hard to remember the opcodes by their bit-patterns, we can assign <em>abstract</em> symbols to opcodes matching their operations by name. This way, we can create <a href="https://en.wikipedia.org/wiki/Assembly_language">Assembly language</a> from the Machine Language. In the previous Machine Language example above, <strong>00110101</strong> (means load the binary <strong>0101</strong>), we can define the symbol <strong>LOAD</strong> referring to <strong>0011</strong> as a higher level abstraction so that <strong>00110101</strong> can be written as <strong>LOAD 0101</strong>.</p>
<p>The utility program that translates the Assembly language to Machine Language is called an <strong><a href="https://en.wikipedia.org/wiki/Assembly_language#Assembler">Assembler</a></strong>.</p>
<h3 id="compiler"><a class="header" href="#compiler">Compiler</a></h3>
<p align="center">
</br>
    <a href><img alt="compiler" src="./img/compiler.svg"> </a>
</p>
<p>A <a href="https://en.wikipedia.org/wiki/Compiler">compiler</a> is any program that translates (maps, encodes) a language A to language B. Each compiler has two major components:</p>
<ul>
<li><strong>Frontend:</strong> deals with mapping the source code string to a structured format called <strong><a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree (AST)</a></strong></li>
<li><strong>Backend (code generator):</strong> translates the AST into the <a href="crash_course.html#bytecode">Bytecode</a> / <a href="crash_course.html#intermediate-representation-ir">IR</a> or Assembly</li>
</ul>
<p>Most often, when we talk about compiler, we mean <strong><a href="https://en.wikipedia.org/wiki/Ahead-of-time_compilation">Ahead-Of-Time (AOT)</a></strong> compiler where the translation happens <em>before</em> execution. Another form of translation is <strong><a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">Just-In-Time (JIT)</a></strong> compilation where translation happens right at the time of the execution.</p>
<p>From the diagram above, to distinguish between a program that translates for example, Python to Assembly vs. Python to Java, the former is called compiler and the latter <strong><a href="https://en.wikipedia.org/wiki/Source-to-source_compiler">transpiler</a></strong> (or source-to-source compiler).</p>
<h4 id="relativity-of-low-level-high-level"><a class="header" href="#relativity-of-low-level-high-level"><em>Relativity of low-level, high-level</em></a></h4>
<p>Assembly is a <em>high-level</em> language compared to the Machine Language but is considered <em>low-level</em> when viewing it from C/C++/Rust. High-level and low-level are relative terms conveying the amount of <em>abstractions</em> involved.</p>
<h3 id="virtual-machine-vm"><a class="header" href="#virtual-machine-vm">Virtual Machine (VM)</a></h3>
<p><a href="crash_course.html#instructions-and-the-machine-language">Instructions</a> are hardware and vendor specific. That is, an Intel CPU instructions are different from AMD CPU. A <strong><a href="https://en.wikipedia.org/wiki/Virtual_machine#Process_virtual_machines">Virtual Machine (VM)</a></strong> abstracts away details of the underlying hardware or operating system so that programs translated/compiled into the VM language becomes platform agnostic. A famous example is the <strong><a href="https://en.wikipedia.org/wiki/Java_virtual_machine">Java Virtual Machine (JVM)</a></strong> which translates/compiles Java programs to JVM language aka Java <strong><a href="https://en.wikipedia.org/wiki/Java_bytecode">Bytecode</a></strong>. Therefore, if you have a valid Java Bytecode and <em>Java Runtime Environment (JRE)</em> in your system, you can execute the Bytecode, regardless on what platform it was compiled on.</p>
<h4 id="bytecode"><a class="header" href="#bytecode">Bytecode</a></h4>
<p>Another technique to translate source code to Machine Code is emulating the Instruction Set with a new (human-friendly) encoding (perhaps easier than assembly). <a href="https://en.wikipedia.org/wiki/Bytecode">Bytecode</a> is such an <em>intermediate language/representation</em> which is lower-level than the actual programming language that it was translated from, and higher-level than Assembly language.</p>
<h4 id="stack-machine"><a class="header" href="#stack-machine">Stack Machine</a></h4>
<p>A <a href="https://en.wikipedia.org/wiki/Stack_machine">Stack Machine</a> is a simple model for a computing machine with two main components:</p>
<ul>
<li>a memory (stack) array keeping the Bytecode instructions that supports <code>push</code>ing and <code>pop</code>ing instructions</li>
<li>an instruction pointer (IP) and stack pointer (SP) guiding which instruction was executed and what is next.</li>
</ul>
<p>We implement a stack-based bytecode VM in the <a href="./01_calculator/vm.html">Calculator VM chapter</a>.</p>
<h3 id="intermediate-representation-ir"><a class="header" href="#intermediate-representation-ir">Intermediate Representation (IR)</a></h3>
<p>Any representation that’s between source code and (usually) Assembly language is considered an <a href="https://en.wikipedia.org/wiki/Intermediate_representation">intermediate representation</a>. Mainstream languages usually have more than one such representations and going from one IR to another IR is called <em>lowering</em>.</p>
<p>We explore <a href="https://en.wikipedia.org/wiki/LLVM#Intermediate_representation">LLVM IR</a> in detail in the <a href="./03_secondlang/ir.html">Secondlang IR chapter</a>.</p>
<h3 id="code-generation"><a class="header" href="#code-generation">Code Generation</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Code_generation_(compiler)">Code generation</a> for a compiler is when the compiler <em>converts an IR to some Machine Code</em>. But it has a wider semantic too for example, when using Rust declarative macro via <code>macro_rules!</code> to automate some repetitive implementations, you’re essentially generating codes (as well as expanding the syntax).</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In conclusion, we want to settle one of the most frequently asked questions</p>
<h2 id="is-python-or-a-language-x-compiled-or-interpreted"><a class="header" href="#is-python-or-a-language-x-compiled-or-interpreted"><span style="color:blue">Is Python (or a language X) Compiled or Interpreted?</span></a></h2>
<p>This is in fact the <span style="color:red">WRONG</span> question to ask!</p>
<p>Being AOT compiled, JIT compiled or interpreted is <strong>implementation-dependent</strong>. For example, the standard Python <em>implementation</em> is <a href="https://www.python.org/"><strong>CPython</strong></a> which compiles a Python source code (in CPython VM) to CPython Bytecode (contents of <code>.pyc</code>) and <strong>interprets</strong> the Bytecode. However, another implementation of Python is <a href="https://www.pypy.org/"><strong>PyPy</strong></a> which (more or less) compiles a Python source code (in PyPy VM) to PyPy Bytecode and <strong>JIT</strong> compiles the PyPy Bytecode to the Machine Code (and is usually faster than CPython interpreter).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calculator"><a class="header" href="#calculator">Calculator</a></h1>
<p>Our first programming language is a simple calculator supporting addition and subtraction. This is perhaps the <em>simplest language</em> that helps us introduce the major topics from grammar to compilation and virtual machines.</p>
<p>If you haven’t cloned the <a href="https://github.com/ehsanmok/create-your-own-lang-with-rust">GitHub</a> repo already, please do and navigate to the <code>calculator</code> subdirectory.</p>
<p>To start, we have <code>1 + 1;</code> in <a href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/calculator/examples/simple.calc">examples/simple.calc</a>. First, build the project:</p>
<pre><code class="language-bash">cargo build --bin main
</code></pre>
<p>This creates an executable at <code>../target/debug/main</code>. Now run it on the example file:</p>
<pre><code class="language-bash">../target/debug/main examples/simple.calc
</code></pre>
<p>Or simply combine both steps with:</p>
<pre><code class="language-bash">cargo run --bin main examples/simple.calc
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="grammar-lexer-parser-pipeline"><a class="header" href="#grammar-lexer-parser-pipeline">Grammar-Lexer-Parser Pipeline</a></h2>
<p>Here is a high-level view of a compiler <em>frontend</em> pipeline</p>
<p align="center">
</br>
    <a href><img alt="grammar, lexer, parser" src="01_calculator/../img/grammar-lexer-parser.svg"> </a>
</p>
<p>Every language needs a (formal) grammar to describe its syntax and semantics. Once a program adheres to the rules of the grammar in <em>Source Code</em> (for example, as an input string or file), it is <em>tokenized</em>. The <em>lexer</em> then adds metadata to each token—for example, where each token starts and finishes in the original source code. Lastly, the <em>parser</em> reshapes or restructures the lexed outputs into an <a href="01_calculator/./ast.html">Abstract Syntax Tree</a>.</p>
<h2 id="grammar"><a class="header" href="#grammar">Grammar</a></h2>
<p>While there are varieties of ways to define the grammar, in this book we will use the <a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">Parsing Expression Grammar (PEG)</a>.</p>
<p>Here is how the grammar for our simple calculator language <code>Calc</code> (supporting addition and subtraction) looks in PEG:</p>
<pre><code class="language-text">Program = _{ SOI ~ Expr ~ EOF }

Expr = { UnaryExpr | BinaryExpr | Term }

Term = _{Int | "(" ~ Expr ~ ")" }

UnaryExpr = { Operator ~ Term }

BinaryExpr = { Term ~ (Operator ~ Term)+ }

Operator = { "+" | "-" }

Int = @{ Operator? ~ ASCII_DIGIT+ }

WHITESPACE = _{ " " | "\t" }

EOF = _{ EOI | ";" }
</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/calculator/src/grammar.pest">calculator/src/grammar.pest</a></p>
<p>This grammar basically defines the syntax and semantics where</p>
<ul>
<li>each <code>Program</code> consists of expressions (<code>Expr</code>)</li>
<li>expressions are either unary (<code>-1</code>) or binary (<code>1 + 2</code>)</li>
<li>unary or binary expressions are made of <code>Term</code> and <code>Operator</code> (<code>"+"</code> and <code>"-"</code>)</li>
<li>the only <em>atom</em> is integer <code>Int</code></li>
</ul>
<p>Given our grammar, we will use <a href="https://pest.rs/">pest</a>, which is a powerful <em>parser generator</em> for PEG grammars. (For more details on pest, check out the <a href="https://pest.rs/book/">pest book</a>.)</p>
<p><code>pest</code> <em>derives</em> the parser <code>CalcParser::parse</code> from our grammar</p>
<pre><code class="language-rust ignore">#[derive(pest_derive::Parser)]
#[grammar = "grammar.pest"]
struct CalcParser;</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/calculator/src/parser.rs">calculator/src/parser.rs</a></p>
<p>and does all the steps of the frontend pipeline that we mentioned so that we can start parsing any <code>Calc</code> source code (<code>source: &amp;str</code>) via the <code>Rule</code>s of our grammar</p>
<pre><code class="language-rust ignore">CalcParser::parse(Rule::Program, source)</code></pre>
<p>Before doing that, we need to define our Abstract Syntax Tree (AST) in the <a href="01_calculator/./ast.html">next section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="abstract-syntax-tree-ast"><a class="header" href="#abstract-syntax-tree-ast">Abstract Syntax Tree (AST)</a></h2>
<p>AST comes into the picture when we want to go from the string representation of our program like <code>"-1"</code> or <code>"1 + 2"</code> to something more manageable and easier to work with. Since our program is not a random string (that’s what the grammar ensures), we can use the structure within the expressions <code>"-1"</code> and <code>"1 + 2"</code> to our advantage and come up with a <em>new representation</em> like a <a href="https://en.wikipedia.org/wiki/Tree_structure">tree</a>:</p>
<p align="center">
  </br>
    <a href><img  alt="ast" src="01_calculator/../img/ast.svg"> </a>
</p>
<p>One thing to note here is that the <em>kinds</em> of nodes in our tree are not the same—the <code>+</code> node is different from the <code>1</code> node. In fact, <code>+</code> has an <strong>Operator</strong> type and <code>1</code> is an integer <strong>Int</strong> type:</p>
<p align="center">
  </br>
    <a href><img  alt="ast" src="01_calculator/../img/ast-typed.svg"> </a>
</p>
<p>so we define our AST nodes as</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Operator {
    Plus,
    Minus,
}

pub enum Node {
    Int(i32),
}
<span class="boring">}</span></code></pre></pre>
<p>Referring back to our grammar, we actually have different kinds of <em>recursive</em> expressions:</p>
<ul>
<li>
<p><strong>unary</strong> grammar</p>
<pre><code>UnaryExpr = { Operator ~ Term }
</code></pre>
</li>
<li>
<p><strong>binary</strong> grammar</p>
<pre><code>BinaryExpr = { Term ~ (Operator ~ Term)* }
</code></pre>
</li>
</ul>
<p>So for example, the expression <code>"-1 + (2 + 3)"</code> has this recursive structure</p>
<p align="center">
</br>
    <a href><img alt="compiler" src="01_calculator/../img/ast-recursive.svg"> </a>
</p>
<p>To include those into our AST to make it an actual <a href="https://en.wikipedia.org/wiki/Binary_tree">tree data structure</a>,
we complete our AST definition as follows</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Operator {
    Plus,
    Minus,
}

pub enum Node {
    Int(i32),
    UnaryExpr {
        op: Operator,
        child: Box&lt;Node&gt;,
    },
    BinaryExpr {
        op: Operator,
        lhs: Box&lt;Node&gt;,
        rhs: Box&lt;Node&gt;,
    },
}
<span class="boring">}</span></code></pre></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/calculator/src/ast.rs">calculator/src/ast.rs</a></p>
<p>Now, we can use the <code>pest</code> generated <code>CalcParser::parse</code> to map the Rules of our <code>Calc</code> language string to our AST.</p>
<pre><code class="language-rust ignore">
pub fn parse(source: &amp;str) -&gt; std::result::Result&lt;Vec&lt;Node&gt;, pest::error::Error&lt;Rule&gt;&gt; {
    let mut ast = vec![];
    let pairs = CalcParser::parse(Rule::Program, source)?;
    for pair in pairs {
        if let Rule::Expr = pair.as_rule() {
            ast.push(build_ast_from_expr(pair));
        }
    }
    Ok(ast)
}</code></pre>
<p>Checkout <a href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/calculator/src/parser.rs">calculator/src/parser.rs</a>.</p>
<p>Note that <code>CalcParser::parse</code> takes care of the AST traversal and correctly maps it to <code>Vec&lt;Node&gt;</code> for easier access
in later stages of compilation.</p>
<h2 id="interpreter"><a class="header" href="#interpreter">Interpreter</a></h2>
<p>The CPU is the <em>ultimate interpreter</em>—it executes opcodes as it goes. After we have changed the representation (a.k.a. <em>lowered</em>) of our source code <code>&amp;str</code> to AST <code>Node</code>, a basic interpreter looks at each node of the AST (via any <a href="https://en.wikipedia.org/wiki/Tree_traversal">tree traversal method</a>) and simply <strong>evaluates</strong> it <em>recursively</em>:</p>
<pre><code class="language-rust ignore">    pub fn eval(&amp;self, node: &amp;Node) -&gt; i32 {
        match node {
            Node::Int(n) =&gt; *n,
            Node::UnaryExpr { op, child } =&gt; {
                let child = self.eval(child);
                match op {
                    Operator::Plus =&gt; child,
                    Operator::Minus =&gt; -child,
                }
            }
            Node::BinaryExpr { op, lhs, rhs } =&gt; {
                let lhs_ret = self.eval(lhs);
                let rhs_ret = self.eval(rhs);

                match op {
                    Operator::Plus =&gt; lhs_ret + rhs_ret,
                    Operator::Minus =&gt; lhs_ret - rhs_ret,
                }
            }
        }
    }</code></pre>
<p>To sum up, we define a <code>Compile</code> trait that we will use throughout this chapter</p>
<pre><code class="language-rust ignore">pub trait Compile {
    type Output;

    fn from_ast(ast: Vec&lt;Node&gt;) -&gt; Self::Output;

    fn from_source(source: &amp;str) -&gt; Self::Output {
        println!("Compiling the source: {}", source);
        let ast: Vec&lt;Node&gt; = parser::parse(source).unwrap();
        println!("{:?}", ast);
        Self::from_ast(ast)
    }
}</code></pre>
<p>and we can now implement our interpreter</p>
<pre><code class="language-rust ignore">pub struct Interpreter;

impl Compile for Interpreter {
    type Output = Result&lt;i32&gt;;

    fn from_ast(ast: Vec&lt;Node&gt;) -&gt; Self::Output {
        let mut ret = 0i32;
        let evaluator = Eval::new();
        for node in ast {
            ret += evaluator.eval(&amp;node);
        }
        Ok(ret)
    }
}</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/calculator/src/compiler/interpreter.rs">calculator/src/compiler/interpreter.rs</a></p>
<p>and test</p>
<pre><code class="language-rust ignore">assert_eq!(Interpreter::from_source("1 + 2").unwrap(), 3);</code></pre>
<p>Run such tests locally with</p>
<pre><code class="language-bash">cargo test interpreter --tests
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="just-in-time-jit-compiler-with-llvm"><a class="header" href="#just-in-time-jit-compiler-with-llvm">Just-In-Time (JIT) Compiler with LLVM</a></h2>
<p>JIT compilation is a combination of Ahead-Of-Time (AOT) compilation and interpretation. As we saw previously, our <code>Calc</code> interpreter evaluates AST to values (actual integer <code>i32</code> values) but a JIT compiler differs from an interpreter in what it outputs. Intuitively, JIT outputs are like AOT outputs but generated at runtime when traversing the AST.</p>
<h3 id="llvm"><a class="header" href="#llvm">LLVM</a></h3>
<p><a href="https://en.wikipedia.org/wiki/LLVM">LLVM</a> (which is <em>not</em> an acronym) is a mature compiler backend (code generator) infrastructure powering many languages such as <a href="https://clang.llvm.org/">Clang</a>, <a href="https://www.rust-lang.org/">Rust</a>, <a href="https://swift.org/">Swift</a>, etc. It has its own IR and Virtual Machine Bytecode abstracting away the underlying platform-specific differences.</p>
<p>We will use <a href="https://github.com/TheDan64/inkwell">inkwell</a> which provides a safe Rust wrapper around LLVM.</p>
<p><strong>Note</strong>: The JIT examples in this chapter require nightly Rust and LLVM installed. The interpreter and VM examples work with stable Rust.</p>
<h3 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h3>
<p>Other code generators that you can use (see the <a href="01_calculator/./exercise.html">exercises</a>) in this book (not at mature as LLVM) are <a href="https://docs.rs/cranelift-simplejit/0.64.0/cranelift_simplejit/index.html">cratelift-simpljit</a> and <a href="https://github.com/swgillespie/gccjit.rs">gcc-jit</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="addition"><a class="header" href="#addition">Addition</a></h2>
<h3 id="setup"><a class="header" href="#setup">Setup</a></h3>
<p>The code is available in <a href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/calculator/examples/llvm/src/main.rs"><code>calculator/examples/llvm/src/main.rs</code></a>. Update the <code>inkwell</code> feature flag to match your LLVM version (check with <code>llvm-config --version</code>):</p>
<pre><code class="language-toml">inkwell = { version = "0.7.1", features = ["llvm20-1"] }  # For LLVM 20.x
</code></pre>
<p>This example requires nightly Rust. Go to <a href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/calculator/examples/llvm/"><code>calculator/examples/llvm</code></a> sub-crate and run:</p>
<pre><code class="language-bash">rustup run nightly cargo run
</code></pre>
<h3 id="add-function"><a class="header" href="#add-function">Add Function</a></h3>
<p>We want to define an add function like</p>
<pre><code>add(x: i32, y: i32) -&gt; i32 { x + y }
</code></pre>
<p>but using the <strong>LLVM language</strong> and JIT it. For that, we need to define <em>every</em> bit of what makes up a function through LLVM basic constructs such as context, module, function signature setups, argument types, basic block, etc.</p>
<p>Here is how to <em>stitch</em> our add function in LLVM</p>
<ol>
<li>We start by creating a <code>context</code>, adding the <code>addition</code> module and setting up the data type we want to use <code>i32_type</code> of type <a href="https://thedan64.github.io/inkwell/inkwell/types/struct.IntType.html"><code>IntType</code></a></li>
</ol>
<pre><code class="language-rust ignore">    let context = Context::create();
    let module = context.create_module("addition");
    let i32_type = context.i32_type();</code></pre>
<ol>
<li>We define the signature of <code>add(i32, i32) -&gt; i32</code>, add the function to our module, create a <a href="https://thedan64.github.io/inkwell/inkwell/basic_block/index.html">basic block</a> entry point and a builder to add later parts</li>
</ol>
<pre><code class="language-rust ignore">
    let fn_type = i32_type.fn_type(&amp;[i32_type.into(), i32_type.into()], false);
    let fn_val = module.add_function("add", fn_type, None);
    let entry_basic_block = context.append_basic_block(fn_val, "entry");

    let builder = context.create_builder();
    builder.position_at_end(entry_basic_block);</code></pre>
<ol>
<li>We create the arguments <code>x</code> and <code>y</code> and add them to the <code>builder</code> to make up the return instruction</li>
</ol>
<pre><code class="language-rust ignore">    let x = fn_val.get_nth_param(0).unwrap().into_int_value();
    let y = fn_val.get_nth_param(1).unwrap().into_int_value();

    let ret = builder.build_int_add(x, y, "add").unwrap();
    let return_instruction = builder.build_return(Some(&amp;ret)).unwrap();</code></pre>
<ol>
<li>Finally, we create a JIT execution engine (with no optimization for now) and let LLVM handle rest of the work for us</li>
</ol>
<pre><code class="language-rust ignore">    let execution_engine = module
        .create_jit_execution_engine(OptimizationLevel::None)
        .unwrap();
    unsafe {
        type Addition = unsafe extern "C" fn(i32, i32) -&gt; i32;
        let add: JitFunction&lt;Addition&gt; = execution_engine.get_function("add").unwrap();
        let x = 1;
        let y = 2;
        assert_eq!(add.call(x, y), x + y);
    }</code></pre>
<p>Yes! all of this just to add two integers.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ast-traversal-patterns"><a class="header" href="#ast-traversal-patterns">AST Traversal Patterns</a></h2>
<p>Recall from the previous section that JITing our <a href="01_calculator/./basic_llvm.html">add function</a> was very detailed and cumbersome to write. Fortunately, there are some useful patterns for traversing complicated ASTs (and IRs)</p>
<ul>
<li><strong>Builder pattern</strong></li>
<li><strong>Visitor pattern</strong> (Will be introduced in chapter 4)</li>
</ul>
<h3 id="builder-pattern"><a class="header" href="#builder-pattern">Builder Pattern</a></h3>
<p>Recall how we have interpreted our AST by traversing recursively and evaluating the nodes</p>
<pre><code class="language-rust  no_run  noplaypen">struct Eval;

impl Eval {
    pub fn new() -&gt; Self {
        Self
    }
    pub fn eval(&amp;self, node: &amp;Node) -&gt; i32 {
        match node {
            Node::Int(n) =&gt; *n,
            Node::UnaryExpr { op, child } =&gt; {
                let child = self.eval(child);
                match op {
                    Operator::Plus =&gt; child,
                    Operator::Minus =&gt; -child,
                }
            }
            Node::BinaryExpr { op, lhs, rhs } =&gt; {
                let lhs_ret = self.eval(lhs);
                let rhs_ret = self.eval(rhs);

                match op {
                    Operator::Plus =&gt; lhs_ret + rhs_ret,
                    Operator::Minus =&gt; lhs_ret - rhs_ret,
                }
            }
        }
    }
}</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/calculator/src/compiler/interpreter.rs">calculator/src/compiler/interpreter.rs</a></p>
<p>but instead, we can take advantage of the <a href="https://thedan64.github.io/inkwell/inkwell/builder/struct.Builder.html">inkwell Builder</a> and recursively traverse our <code>Calc</code> AST as follows</p>
<pre><code class="language-rust  no_run  noplaypen">struct RecursiveBuilder&lt;'a&gt; {
    i32_type: IntType&lt;'a&gt;,
    builder: &amp;'a Builder&lt;'a&gt;,
}

impl&lt;'a&gt; RecursiveBuilder&lt;'a&gt; {
    pub fn new(i32_type: IntType&lt;'a&gt;, builder: &amp;'a Builder) -&gt; Self {
        Self { i32_type, builder }
    }
    pub fn build(&amp;self, ast: &amp;Node) -&gt; IntValue&lt;'a&gt; {
        match ast {
            Node::Int(n) =&gt; self.i32_type.const_int(*n as u64, true),
            Node::UnaryExpr { op, child } =&gt; {
                let child = self.build(child);
                match op {
                    Operator::Minus =&gt; child.const_neg(),
                    Operator::Plus =&gt; child,
                }
            }
            Node::BinaryExpr { op, lhs, rhs } =&gt; {
                let left = self.build(lhs);
                let right = self.build(rhs);

                match op {
                    Operator::Plus =&gt; self
                        .builder
                        .build_int_add(left, right, "plus_temp")
                        .unwrap(),
                    Operator::Minus =&gt; self
                        .builder
                        .build_int_sub(left, right, "minus_temp")
                        .unwrap(),
                }
            }
        }
    }
}</code></pre>
<p>and similar to our addition example, we can JIT the builder output</p>
<pre><code class="language-rust  no_run  noplaypen">pub struct Jit;

impl Compile for Jit {
    type Output = Result&lt;i32&gt;;

    fn from_ast(ast: Vec&lt;Node&gt;) -&gt; Self::Output {
        let context = Context::create();
        let module = context.create_module("calculator");

        let builder = context.create_builder();

        let execution_engine = module
            .create_jit_execution_engine(OptimizationLevel::None)
            .unwrap();

        let i32_type = context.i32_type();
        let fn_type = i32_type.fn_type(&amp;[], false);

        let function = module.add_function("jit", fn_type, None);
        let basic_block = context.append_basic_block(function, "entry");

        builder.position_at_end(basic_block);

        for node in ast {
            let recursive_builder = RecursiveBuilder::new(i32_type, &amp;builder);
            let return_value = recursive_builder.build(&amp;node);
            let _ = builder.build_return(Some(&amp;return_value));
        }
        println!(
            "Generated LLVM IR: {}",
            function.print_to_string().to_string()
        );

        unsafe {
            let jit_function: JitFunction&lt;JitFunc&gt; = execution_engine.get_function("jit").unwrap();

            Ok(jit_function.call())
        }
    }
}</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/calculator/src/compiler/jit.rs">calculator/src/compiler/jit.rs</a></p>
<p>Finally, we can test it</p>
<pre><code class="language-rust ignore">assert_eq!(Jit::from_source("1 + 2").unwrap(), 3)</code></pre>
<p>Run such tests locally with</p>
<pre><code class="language-bash">cargo test jit --tests
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="virtual-machine"><a class="header" href="#virtual-machine">Virtual Machine</a></h2>
<p>Recall from the <a href="01_calculator/../crash_course.html#virtual-machine-vm">crash course</a> that a (process) VM abstracts away hardware-specific instructions so that its Bytecodes (abstract instructions) can be executed in any environment that has Bytecode runtime support. To create our VM and its runtime, we need to define our:</p>
<ul>
<li>Opcodes (new encoding atoms)</li>
<li>Bytecode representation and</li>
<li><strong>Runtime model</strong>  as <a href="01_calculator/../crash_course.html#stack-machine">Stack Machine</a></li>
</ul>
<h3 id="opcode"><a class="header" href="#opcode">Opcode</a></h3>
<p>Since our expression-based <code>Calc</code> language is made up of:</p>
<ul>
<li><em>constant</em> integers</li>
<li><em>unary</em> (plus, minus sign) operators and</li>
<li><em>binary</em> (addition, subtraction) operators</li>
</ul>
<p>we can define our new opcode encodings like</p>
<pre><code class="language-rust ignore">pub enum OpCode {
    OpConstant(u16), // pointer to constant table
    OpPop,           // pop is needed for execution
    OpAdd,
    OpSub,
    OpPlus,
    OpMinus,
}</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/calculator/src/compiler/vm/opcode.rs">calculator/src/compiler/vm/opcode.rs</a></p>
<p>We choose the simplest form of encoding—encoding the ops as bytes <code>u8</code> (in hex format):</p>
<pre><code class="language-rust ignore">        OpCode::OpConstant(arg) =&gt; make_three_byte_op(0x01, arg),
        OpCode::OpPop =&gt; vec![0x02],  // decimal repr is 2
        OpCode::OpAdd =&gt; vec![0x03],  // decimal repr is 3
        OpCode::OpSub =&gt; vec![0x04],  // decimal repr is 4
        OpCode::OpPlus =&gt; vec![0x0A], // decimal repr is 10
        OpCode::OpMinus =&gt; vec![0x0B], // decimal repr is 11</code></pre>
<p>For ease of access, we store constant <code>Node::Int(i32)</code> nodes in a separate memory, and <code>OpConstant(arg)</code> tracks these values.
In a unary expression like <code>"1"</code>, we encode <code>Node::Int(1)</code> as the opcode <code>[1, 0, 0]</code> as the first constant. (<strong>0x01</strong> in decimal is <strong>1</strong>).</p>
<h3 id="bytecode-1"><a class="header" href="#bytecode-1">Bytecode</a></h3>
<p>We define</p>
<pre><code class="language-rust ignore">pub struct Bytecode {
    pub instructions: Vec&lt;u8&gt;,
    pub constants: Vec&lt;Node&gt;,
}</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/calculator/src/compiler/vm/bytecode.rs">calculator/src/compiler/vm/bytecode.rs</a></p>
<p>and pictorially, here is how <code>"1 + 2"</code> AST to Bytecode conversion would look like</p>
<p align="center">
</br>
    <a href><img alt="ast bytecode" src="01_calculator/../img/ast-bytecode.svg"> </a>
</p>
<p>and in Rust</p>
<pre><code class="language-rust  ignore">ByteCode {
    instructions: [1, 0, 0, 1, 0, 1, 3, 2],
    constants: [Int(1), Int(2)]
}</code></pre>
<p>Now, we can implement our Bytecode interpreter</p>
<pre><code class="language-rust ignore">pub struct Interpreter {
    bytecode: Bytecode,
}

impl Compile for Interpreter {
    type Output = Bytecode;

    fn from_ast(ast: Vec&lt;Node&gt;) -&gt; Self::Output {
        let mut interpreter = Interpreter {
            bytecode: Bytecode::new(),
        };
        for node in ast {
            println!("compiling node {:?}", node);
            interpreter.interpret_node(node);
            // pop one element from the stack after
            // each expression statement to clean up
            interpreter.add_instruction(OpCode::OpPop);
        }
        interpreter.bytecode
    }
}</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/calculator/src/compiler/vm/bytecode.rs">calculator/src/compiler/vm/bytecode.rs</a></p>
<h3 id="runtime"><a class="header" href="#runtime">Runtime</a></h3>
<p>From the previous example, our interpreter goes through the bytecode instructions and executes them.</p>
<p>Continuing our <code>"1 + 2"</code> Bytecode example,</p>
<pre><code class="language-text">instructions: [1, 0, 0, 1, 0, 1,   3,   2],
              -------- --------    -    -
                 |         |       |    |
constants: [  Int(1),   Int(2)]  OpAdd  OpPop

[1, 0, 0] points to the first element in the constants table, i.e., Int(1)
[1, 0, 1] points to Int(2)
[3] (or [0x03]) corresponding to the Opcode *OpAdd*, performs the addition operation Int(1 + 2)
[2] (or [0x02]) corresponding to the Opcode *OpPop* pops out the computed Bytecodes
</code></pre>
<p>Since we want to model our runtime as a Stack Machine, we define our VM as a struct with Bytecode, stack memory (in Stack Machine), and a stack pointer to the next free space:</p>
<pre><code class="language-rust ignore">const STACK_SIZE: usize = 512;

pub struct VM {
    bytecode: Bytecode,
    stack: [Node; STACK_SIZE],
    stack_ptr: usize, // points to the next free space
}</code></pre>
<p>and with the help of <em>instruction pointer (IP)</em>, we execute the Bytecodes as follows</p>
<pre><code class="language-rust ignore">    pub fn run(&amp;mut self) {
        let mut ip = 0; // instruction pointer
        while ip &lt; self.bytecode.instructions.len() {
            let inst_addr = ip;
            ip += 1;

            match self.bytecode.instructions[inst_addr] {
                0x01 =&gt; {
                    //OpConst
                    let const_idx = convert_two_u8s_to_usize(
                        self.bytecode.instructions[ip],
                        self.bytecode.instructions[ip + 1],
                    );
                    ip += 2;
                    self.push(self.bytecode.constants[const_idx].clone());
                }
                0x02 =&gt; {
                    //OpPop
                    self.pop();
                }
                0x03 =&gt; {
                    // OpAdd
                    match (self.pop(), self.pop()) {
                        (Node::Int(rhs), Node::Int(lhs)) =&gt; self.push(Node::Int(lhs + rhs)),
                        _ =&gt; panic!("Unknown types to OpAdd"),
                    }
                }
                0x04 =&gt; {
                    // OpSub
                    match (self.pop(), self.pop()) {
                        (Node::Int(rhs), Node::Int(lhs)) =&gt; self.push(Node::Int(lhs - rhs)),
                        _ =&gt; panic!("Unknown types to OpSub"),
                    }
                }
                0x0A =&gt; {
                    // OpPlus
                    match self.pop() {
                        Node::Int(num) =&gt; self.push(Node::Int(num)),
                        _ =&gt; panic!("Unknown arg type to OpPlus"),
                    }
                }
                0x0B =&gt; {
                    // OpMinus
                    match self.pop() {
                        Node::Int(num) =&gt; self.push(Node::Int(-num)),
                        _ =&gt; panic!("Unknown arg type to OpMinus"),
                    }
                }
                _ =&gt; panic!("Unknown instruction"),
            }
        }
    }

    pub fn push(&amp;mut self, node: Node) {
        self.stack[self.stack_ptr] = node;
        self.stack_ptr += 1; // ignoring the potential stack overflow
    }

    pub fn pop(&amp;mut self) -&gt; Node {
        // ignoring the potential of stack underflow
        // cloning rather than mem::replace for easier testing
        let node = self.stack[self.stack_ptr - 1].clone();
        self.stack_ptr -= 1;
        node
    }</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/calculator/src/compiler/vm/vm.rs">calculator/src/compiler/vm/vm.rs</a></p>
<p>To examine the generated Bytecodes and run our VM, we can do</p>
<pre><code class="language-rust ignore">let byte_code = Interpreter::from_source(source);
println!("byte code: {:?}", byte_code);
let mut vm = VM::new(byte_code);
vm.run();
println!("{}", vm.pop_last());</code></pre>
<p>Run tests locally for our VM with</p>
<pre><code class="language-bash">cargo test vm --tests
</code></pre>
<p>Checkout the <a href="01_calculator/./repl.html">next section</a> on how to create a REPL for our <code>Calc</code> to compare different compilation paths.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="read-eval-print-loop-repl"><a class="header" href="#read-eval-print-loop-repl">Read-Eval-Print Loop (REPL)</a></h2>
<p>REPL (as its name implies) loops through every line of the input and compiles it. We use <a href="https://github.com/kkawakam/rustyline">rustyline</a> crate to create our REPL. For each line of input, we can optionally choose to</p>
<ul>
<li>directly interpret the AST</li>
<li>JIT the AST</li>
<li>compile to our bytecode VM and interpret it</li>
</ul>
<pre><code class="language-rust no_run noplaypen">fn main() -&gt; Result&lt;()&gt; {
    let mut rl = DefaultEditor::new()?;
    println!("Calculator prompt. Expressions are line evaluated.");
    loop {
        let readline = rl.readline("&gt;&gt; ");
        match readline {
            Ok(line) =&gt; {
                cfg_if! {
                    if #[cfg(any(feature = "jit", feature = "interpreter"))] {
                        match Engine::from_source(&amp;line) {
                            Ok(result) =&gt; println!("{}", result),
                            Err(e) =&gt; eprintln!("{}", e),
                        };
                    }
                    else if #[cfg(feature = "vm")] {
                        let byte_code = Engine::from_source(&amp;line);
                        println!("byte code: {:?}", byte_code);
                        let mut vm = VM::new(byte_code);
                        vm.run();
                        println!("{}", vm.pop_last());
                    }
                }
            }
            Err(ReadlineError::Interrupted) =&gt; {
                println!("CTRL-C");
                break;
            }
            Err(ReadlineError::Eof) =&gt; {
                println!("CTRL-D");
                break;
            }
            Err(err) =&gt; {
                println!("Error: {:?}", err);
                break;
            }
        }
    }
    Ok(())</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/calculator/src/bin/repl.rs">calculator/src/bin/repl.rs</a></p>
<p>Now, we can use run the REPL and choose different compilation path</p>
<pre><code class="language-bash"># Interpreter (stable Rust)
cargo run --bin repl --features interpreter

# Bytecode VM (stable Rust)
cargo run --bin repl --features vm

# JIT (requires nightly Rust + LLVM)
rustup run nightly cargo run --bin repl --features jit
</code></pre>
<p>In any of them, you should see the prompt like</p>
<pre><code class="language-text">Calculator prompt. Expressions are line evaluated.
&gt;&gt;&gt;
</code></pre>
<p>waiting for your inputs. Here are some sample outputs of different compilation paths in debug mode.</p>
<ul>
<li>with <code>--features jit</code></li>
</ul>
<pre><code class="language-text">Calculator prompt. Expressions are line evaluated.
&gt;&gt; 1 + 2
Compiling the source: 1 + 2
[BinaryExpr { op: Plus, lhs: Int(1), rhs: Int(2) }]
Generated LLVM IR: define i32 @jit() {
entry:
  ret i32 3
}

3
&gt;&gt; (1 + 2) - (8 - 10)
Compiling the source: (1 + 2) - (8 - 10)
[BinaryExpr { op: Minus, lhs: BinaryExpr { op: Plus, lhs: Int(1), rhs: Int(2) }, rhs: BinaryExpr { op: Minus, lhs: Int(8), rhs: Int(10) } }]
Generated LLVM IR: define i32 @jit() {
entry:
  ret i32 5
}

5
&gt;&gt;
CTRL-C
</code></pre>
<ul>
<li>with <code>--features vm</code></li>
</ul>
<pre><code class="language-text">Calculator prompt. Expressions are line evaluated.
&gt;&gt; 1 + 2
Compiling the source: 1 + 2
[BinaryExpr { op: Plus, lhs: Int(1), rhs: Int(2) }]
compiling node BinaryExpr { op: Plus, lhs: Int(1), rhs: Int(2) }
added instructions [1, 0, 0] from opcode OpConstant(0)
added instructions [1, 0, 0, 1, 0, 1] from opcode OpConstant(1)
added instructions [1, 0, 0, 1, 0, 1, 3] from opcode OpAdd
added instructions [1, 0, 0, 1, 0, 1, 3, 2] from opcode OpPop
byte code: Bytecode { instructions: [1, 0, 0, 1, 0, 1, 3, 2], constants: [Int(1), Int(2)] }
3
&gt;&gt; (1 + 2) - (8 - 10)
Compiling the source: (1 + 2) - (8 - 10)
[BinaryExpr { op: Minus, lhs: BinaryExpr { op: Plus, lhs: Int(1), rhs: Int(2) }, rhs: BinaryExpr { op: Minus, lhs: Int(8), rhs: Int(10) } }]
compiling node BinaryExpr { op: Minus, lhs: BinaryExpr { op: Plus, lhs: Int(1), rhs: Int(2) }, rhs: BinaryExpr { op: Minus, lhs: Int(8), rhs: Int(10) } }
added instructions [1, 0, 0] from opcode OpConstant(0)
added instructions [1, 0, 0, 1, 0, 1] from opcode OpConstant(1)
added instructions [1, 0, 0, 1, 0, 1, 3] from opcode OpAdd
added instructions [1, 0, 0, 1, 0, 1, 3, 1, 0, 2] from opcode OpConstant(2)
added instructions [1, 0, 0, 1, 0, 1, 3, 1, 0, 2, 1, 0, 3] from opcode OpConstant(3)
added instructions [1, 0, 0, 1, 0, 1, 3, 1, 0, 2, 1, 0, 3, 4] from opcode OpSub
added instructions [1, 0, 0, 1, 0, 1, 3, 1, 0, 2, 1, 0, 3, 4, 4] from opcode OpSub
added instructions [1, 0, 0, 1, 0, 1, 3, 1, 0, 2, 1, 0, 3, 4, 4, 2] from opcode OpPop
byte code: Bytecode { instructions: [1, 0, 0, 1, 0, 1, 3, 1, 0, 2, 1, 0, 3, 4, 4, 2], constants: [Int(1), Int(2), Int(8), Int(10)] }
5
&gt;&gt;&gt;
CTRL-C
</code></pre>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>This concludes our <a href="01_calculator/./calc_intro.html">Calculator</a> chapter. We took advantage of the simplicity of our <code>Calc</code> language to touch on a lot of topics.</p>
<p>Thanks for following along and reading up this far!</p>
<p>Stay tuned for the next chapter where we gradually work our way up to create a statically typed language named creatively as <strong>Firstlang</strong> :D</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>To get most out of this chapter, it is recommended to at least try the first exercise below</p>
<ol>
<li>Add support for multiplication and division to the calculator and allow computations on floating numbers <code>f32</code>. Can you include standard operator precedence?</li>
<li>JIT with <a href="https://docs.rs/cranelift-simplejit/0.64.0/cranelift_simplejit/">cranelift-simplejit</a></li>
<li>JIT with <a href="https://github.com/swgillespie/gccjit.rs">gcc-jit</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="firstlang-your-first-real-language"><a class="header" href="#firstlang-your-first-real-language">Firstlang: Your First Real Language</a></h1>
<p>In Part I, we built a <a href="02_firstlang/../01_calculator/calc_intro.html">calculator</a> that could evaluate arithmetic expressions. While useful for learning the basics, it was not really a <em>programming language</em> - you cannot define functions, store values in variables, or make decisions with conditionals.</p>
<p>In this chapter, we build <strong>Firstlang</strong>, a complete interpreted programming language.</p>
<h2 id="what-changes-from-calculator"><a class="header" href="#what-changes-from-calculator">What Changes from Calculator?</a></h2>
<h3 id="grammar-from-18-lines-to-70-lines"><a class="header" href="#grammar-from-18-lines-to-70-lines">Grammar: From 18 Lines to 70 Lines</a></h3>
<p>The Calculator grammar was minimal:</p>
<pre><code class="language-text">Program = _{ SOI ~ Expr ~ EOF }
Expr = { UnaryExpr | BinaryExpr | Term }
Term = _{Int | "(" ~ Expr ~ ")" }
UnaryExpr = { Operator ~ Term }
BinaryExpr = { Term ~ (Operator ~ Term)+ }
Operator = { "+" | "-" }
Int = @{ Operator? ~ ASCII_DIGIT+ }
</code></pre>
<p>Firstlang adds <em>statements</em>, <em>identifiers</em>, <em>functions</em>, and <em>control flow</em>:</p>
<pre><code class="language-text">// New: Statements instead of just expressions
Program = _{ SOI ~ Stmt* ~ EOI }
Stmt = { Function | Return | Assignment | Expr }

// New: Identifiers for variables and function names
Identifier = @{ !KEYWORD ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// New: Functions with parameters
Function = { "def" ~ Identifier ~ "(" ~ Params? ~ ")" ~ Block }

// New: Control flow
Conditional = { "if" ~ "(" ~ Expr ~ ")" ~ Block ~ "else" ~ Block }
WhileLoop = { "while" ~ "(" ~ Expr ~ ")" ~ Block }
</code></pre>
<h3 id="ast-from-2-node-types-to-8"><a class="header" href="#ast-from-2-node-types-to-8">AST: From 2 Node Types to 8</a></h3>
<p>Calculator had just <code>Int</code> and <code>BinaryExpr</code>. Firstlang needs:</p>
<div class="table-wrapper"><table><thead><tr><th>Node</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>Int</code>, <code>Bool</code></td><td>Literal values</td></tr>
<tr><td><code>Var</code></td><td>Variable reference</td></tr>
<tr><td><code>Binary</code>, <code>Unary</code></td><td>Operators</td></tr>
<tr><td><code>Call</code></td><td>Function call</td></tr>
<tr><td><code>If</code>, <code>While</code></td><td>Control flow</td></tr>
<tr><td><code>Function</code></td><td>Function definition</td></tr>
<tr><td><code>Return</code>, <code>Assignment</code></td><td>Statements</td></tr>
</tbody></table>
</div>
<h3 id="execution-from-expression-evaluation-to-statement-execution"><a class="header" href="#execution-from-expression-evaluation-to-statement-execution">Execution: From Expression Evaluation to Statement Execution</a></h3>
<p>Calculator evaluated a single expression and returned a value. Firstlang executes a sequence of statements, maintains variable bindings, and handles function calls with a call stack.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<ul>
<li><strong>Variables and assignment</strong> (<code>x = 42</code>)</li>
<li><strong>Functions with parameters</strong> (<code>def add(a, b) { return a + b }</code>)</li>
<li><strong>Conditionals</strong> (<code>if (condition) { ... } else { ... }</code>)</li>
<li><strong>Loops</strong> (<code>while (condition) { ... }</code>)</li>
<li><strong>Recursion</strong> - functions that call themselves</li>
</ul>
<p>Our ultimate goal is to compute the Fibonacci sequence recursively:</p>
<pre><code class="language-python">def fib(n) {
    if (n &lt; 2) {
        return n
    } else {
        return fib(n - 1) + fib(n - 2)
    }
}

fib(10)  # Returns 55
</code></pre>
<h2 id="why-an-interpreter-first"><a class="header" href="#why-an-interpreter-first">Why an Interpreter First?</a></h2>
<p>Before we dive into compilation (which we do in <a href="02_firstlang/../03_secondlang/intro.html">Secondlang</a>), we build a simple <strong>tree-walking interpreter</strong>. This approach:</p>
<ol>
<li><strong>Is simpler</strong> - No need to generate machine code</li>
<li><strong>Provides immediate feedback</strong> - Great for a REPL</li>
<li><strong>Teaches the fundamentals</strong> - How programs actually execute</li>
</ol>
<p>The concepts you learn here (scoping, call stacks, evaluation) apply directly to understanding how compiled languages work.</p>
<h2 id="what-you-will-learn"><a class="header" href="#what-you-will-learn">What You Will Learn</a></h2>
<ol>
<li><strong>Grammar Design</strong> - How to specify a Python-like syntax</li>
<li><strong>AST Design</strong> - Representing programs as data structures</li>
<li><strong>Variable Scoping</strong> - How variables are stored and looked up</li>
<li><strong>Function Calls</strong> - Managing the call stack for recursion</li>
<li><strong>Control Flow</strong> - Implementing conditionals and loops</li>
</ol>
<h2 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h2>
<p>Navigate to the <code>firstlang</code> subdirectory in the repository:</p>
<pre><code class="language-bash">cd create-your-own-lang-with-rust/firstlang
</code></pre>
<p>The structure is:</p>
<pre><code>firstlang/
├── Cargo.toml
├── src/
│   ├── lib.rs          # Library exports
│   ├── main.rs         # CLI and REPL
│   ├── grammar.pest    # PEG grammar (70 lines)
│   ├── parser.rs       # AST construction
│   ├── ast.rs          # AST definitions
│   └── interpreter.rs  # Tree-walking interpreter
└── examples/
    ├── fibonacci.fl    # Recursive fibonacci
    ├── factorial.fl    # Factorial examples
    └── basics.fl       # Basic examples
</code></pre>
<p>Compare to Calculator:</p>
<pre><code>calculator/
├── src/
│   ├── grammar.pest         # Minimal grammar (18 lines)
│   ├── parser.rs            # Simpler parsing
│   ├── ast.rs               # Just Int and BinaryExpr
│   └── compiler/
│       ├── interpreter.rs   # Expression evaluator
│       ├── jit.rs           # LLVM JIT (explored later)
│       └── vm/              # Bytecode VM (explored later)
</code></pre>
<p>We focus on a single backend (the interpreter) to deeply understand the new concepts without distraction.</p>
<h2 id="running-firstlang"><a class="header" href="#running-firstlang">Running Firstlang</a></h2>
<p>You can run a Firstlang file:</p>
<pre><code class="language-bash">cargo run -- examples/fibonacci.fl
# Output: 55
</code></pre>
<p>Or start the REPL:</p>
<pre><code class="language-bash">cargo run
# Firstlang REPL v0.1.0
# &gt;&gt;&gt; 1 + 2
# 3
# &gt;&gt;&gt; def double(x) { return x * 2 }
# &gt;&gt;&gt; double(21)
# 42
</code></pre>
<p>Let us dive in.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-like-syntax"><a class="header" href="#python-like-syntax">Python-like Syntax</a></h1>
<p>Firstlang uses a Python-inspired syntax that’s familiar and easy to read. Let’s look at the grammar.</p>
<h2 id="the-grammar"><a class="header" href="#the-grammar">The Grammar</a></h2>
<p>Our grammar is defined using <a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">PEG (Parsing Expression Grammar)</a> via the <code>pest</code> library. If you need a refresher on pest syntax (<code>~</code>, <code>|</code>, <code>*</code>, <code>@{}</code>, etc.), see the <a href="02_firstlang/../crash_course.html#peg-and-pest-syntax">PEG and pest Syntax</a> section. Here are the key constructs:</p>
<h3 id="expressions"><a class="header" href="#expressions">Expressions</a></h3>
<pre><code class="language-pest">// Basic values
Int = @{ ASCII_DIGIT+ }           // 42, 123
Bool = @{ "true" | "false" }       // true, false
Identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }  // x, myVar

// Operators (by precedence)
Comparison = { Additive ~ (CompOp ~ Additive)* }    // x &lt; 10
Additive = { Multiplicative ~ (AddOp ~ Multiplicative)* }  // x + y
Multiplicative = { Unary ~ (MulOp ~ Unary)* }       // x * y
Unary = { UnaryOp ~ Unary | Call }                  // -x, !flag
</code></pre>
<h3 id="statements"><a class="header" href="#statements">Statements</a></h3>
<pre><code class="language-pest">// Variable assignment
Assignment = { Identifier ~ "=" ~ Expr }
// Example: x = 42

// Return statement
Return = { "return" ~ Expr }
// Example: return x + 1

// Function definition
Function = { "def" ~ Identifier ~ "(" ~ Params? ~ ")" ~ Block }
// Example: def add(a, b) { return a + b }
</code></pre>
<h3 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h3>
<pre><code class="language-pest">// Conditional
Conditional = { "if" ~ "(" ~ Expr ~ ")" ~ Block ~ "else" ~ Block }
// Example: if (x &lt; 10) { 1 } else { 2 }

// While loop
WhileLoop = { "while" ~ "(" ~ Expr ~ ")" ~ Block }
// Example: while (x &lt; 10) { x = x + 1 }

// Block of statements
Block = { "{" ~ Stmt* ~ "}" }
</code></pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="simple-arithmetic"><a class="header" href="#simple-arithmetic">Simple Arithmetic</a></h3>
<pre><code class="language-python">1 + 2 * 3       # = 7 (multiplication first)
(1 + 2) * 3     # = 9 (parentheses override)
-5 + 3          # = -2 (unary minus)
</code></pre>
<h3 id="variables"><a class="header" href="#variables">Variables</a></h3>
<pre><code class="language-python">x = 10
y = x + 5       # = 15
</code></pre>
<h3 id="functions"><a class="header" href="#functions">Functions</a></h3>
<pre><code class="language-python">def greet() {
    return 42
}

def add(a, b) {
    return a + b
}

add(3, 4)       # = 7
</code></pre>
<h3 id="conditionals"><a class="header" href="#conditionals">Conditionals</a></h3>
<pre><code class="language-python">def max(a, b) {
    if (a &gt; b) {
        return a
    } else {
        return b
    }
}

max(10, 20)     # = 20
</code></pre>
<h3 id="loops"><a class="header" href="#loops">Loops</a></h3>
<pre><code class="language-python">x = 0
while (x &lt; 5) {
    x = x + 1
}
x               # = 5
</code></pre>
<h3 id="recursion"><a class="header" href="#recursion">Recursion</a></h3>
<pre><code class="language-python">def factorial(n) {
    if (n &lt;= 1) {
        return 1
    } else {
        return n * factorial(n - 1)
    }
}

factorial(5)    # = 120
</code></pre>
<h2 id="full-grammar"><a class="header" href="#full-grammar">Full Grammar</a></h2>
<p>The complete grammar is in <code>src/grammar.pest</code>. The key design choices are:</p>
<ol>
<li><strong>Whitespace insensitive</strong> - Unlike Python, braces <code>{}</code> delimit blocks</li>
<li><strong>No semicolons</strong> - Newlines separate statements</li>
<li><strong>Parentheses required</strong> - For <code>if</code> and <code>while</code> conditions</li>
<li><strong>Expression-based</strong> - Everything returns a value</li>
</ol>
<p>In the <a href="02_firstlang/./variables.html">next section</a>, we’ll see how variables work and how the interpreter manages scope.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables-and-assignment"><a class="header" href="#variables-and-assignment">Variables and Assignment</a></h1>
<p>Variables let us store values and refer to them by name. In Firstlang, assignment is simple:</p>
<pre><code class="language-python">x = 42
name = x + 8    # name = 50
</code></pre>
<h2 id="how-variables-work"><a class="header" href="#how-variables-work">How Variables Work</a></h2>
<h3 id="the-ast"><a class="header" href="#the-ast">The AST</a></h3>
<p>In our AST, assignment is represented as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Stmt {
    Assignment { name: String, value: Expr },
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="storage-the-environment"><a class="header" href="#storage-the-environment">Storage: The Environment</a></h3>
<p>Variables are stored in a <code>HashMap</code> inside our interpreter:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Frame {
    locals: HashMap&lt;String, Value&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>When we encounter an assignment like <code>x = 42</code>:</p>
<ol>
<li>Evaluate the right-hand side expression</li>
<li>Store the result in the current frame’s <code>locals</code></li>
</ol>
<h3 id="variable-lookup"><a class="header" href="#variable-lookup">Variable Lookup</a></h3>
<p>When we encounter a variable reference like <code>x</code>:</p>
<ol>
<li>Look in the current frame’s locals</li>
<li>If not found, look in globals (for functions)</li>
<li>If still not found, error: “Undefined variable”</li>
</ol>
<h2 id="scoping"><a class="header" href="#scoping">Scoping</a></h2>
<p>Firstlang uses simple scoping rules:</p>
<pre><code class="language-python">x = 10          # global scope

def foo() {
    y = 20      # local to foo
    return x + y
}

foo()           # = 30 (can access global x)
</code></pre>
<p>Variables inside functions are local to that function. Global variables (defined outside functions) are visible everywhere.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><code class="language-python"># Variables and arithmetic
a = 5
b = 3
sum = a + b     # 8
diff = a - b    # 2
prod = a * b    # 15

# Reassignment
x = 1
x = x + 1
x = x * 2
x               # 4
</code></pre>
<p>In the <a href="02_firstlang/./functions.html">next section</a>, we’ll see how functions use these building blocks.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-1"><a class="header" href="#functions-1">Functions</a></h1>
<p>Functions are the heart of any programming language. They let us:</p>
<ul>
<li><strong>Name</strong> a piece of computation</li>
<li><strong>Parameterize</strong> it with inputs</li>
<li><strong>Reuse</strong> it multiple times</li>
</ul>
<h2 id="defining-functions"><a class="header" href="#defining-functions">Defining Functions</a></h2>
<p>In Firstlang, we define functions with <code>def</code>:</p>
<pre><code class="language-python">def add(a, b) {
    return a + b
}
</code></pre>
<p>This creates a function named <code>add</code> that takes two parameters <code>a</code> and <code>b</code>, and returns their sum.</p>
<h2 id="the-ast-1"><a class="header" href="#the-ast-1">The AST</a></h2>
<p>Functions are represented in our AST as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Stmt {
    Function {
        name: String,
        params: Vec&lt;String&gt;,
        body: Vec&lt;Stmt&gt;,
    },
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="how-function-calls-work"><a class="header" href="#how-function-calls-work">How Function Calls Work</a></h2>
<p>When we call <code>add(3, 4)</code>:</p>
<ol>
<li><strong>Look up</strong> the function by name</li>
<li><strong>Evaluate</strong> the arguments (3 and 4)</li>
<li><strong>Create a new frame</strong> for this call</li>
<li><strong>Bind parameters</strong> to argument values (<code>a = 3, b = 4</code>)</li>
<li><strong>Execute</strong> the function body</li>
<li><strong>Return</strong> the result and pop the frame</li>
</ol>
<p>Here’s the key interpreter code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Expr::Call { name, args } =&gt; {
    // Look up function
    let func = self.lookup_var(name)?;

    if let Value::Function { params, body } = func {
        // Evaluate arguments
        let arg_values = args.iter()
            .map(|a| self.eval_expr(a))
            .collect();

        // Create new frame with parameter bindings
        let mut frame = Frame::new();
        for (param, arg) in params.iter().zip(arg_values) {
            frame.locals.insert(param.clone(), arg);
        }

        // Push frame, execute, pop frame
        self.call_stack.push(frame);
        let result = self.execute_body(&amp;body)?;
        self.call_stack.pop();

        Ok(result)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="the-call-stack"><a class="header" href="#the-call-stack">The Call Stack</a></h2>
<p>Each function call creates a new “frame” on the call stack. This is crucial for:</p>
<ul>
<li><strong>Local variables</strong> - Each call has its own <code>a</code> and <code>b</code></li>
<li><strong>Recursion</strong> - Multiple calls can be “in flight” simultaneously</li>
</ul>
<pre><code class="language-python">def outer() {
    x = 1
    return inner()
}

def inner() {
    y = 2
    return y
}

outer()
</code></pre>
<p>During execution:</p>
<pre><code>Call Stack:
┌─────────────┐
│ inner       │  ← current frame (y = 2)
│ x = 1, y = ?│
├─────────────┤
│ outer       │  ← previous frame (x = 1)
│ x = 1       │
├─────────────┤
│ global      │
└─────────────┘
</code></pre>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="simple-function"><a class="header" href="#simple-function">Simple Function</a></h3>
<pre><code class="language-python">def square(x) {
    return x * x
}

square(5)       # 25
</code></pre>
<h3 id="multiple-parameters"><a class="header" href="#multiple-parameters">Multiple Parameters</a></h3>
<pre><code class="language-python">def area(width, height) {
    return width * height
}

area(4, 5)      # 20
</code></pre>
<h3 id="function-composition"><a class="header" href="#function-composition">Function Composition</a></h3>
<pre><code class="language-python">def double(x) {
    return x * 2
}

def quadruple(x) {
    return double(double(x))
}

quadruple(5)    # 20
</code></pre>
<p>Next, we’ll add <a href="02_firstlang/./control_flow.html">control flow</a> to make our functions more powerful.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow-ifelse-and-while"><a class="header" href="#control-flow-ifelse-and-while">Control Flow: If/Else and While</a></h1>
<p>Control flow lets our programs make decisions and repeat operations.</p>
<h2 id="conditionals-ifelse"><a class="header" href="#conditionals-ifelse">Conditionals: If/Else</a></h2>
<p>The <code>if</code> expression evaluates a condition and executes one of two branches:</p>
<pre><code class="language-python">if (x &gt; 0) {
    return 1
} else {
    return 0
}
</code></pre>
<h3 id="implementation"><a class="header" href="#implementation">Implementation</a></h3>
<p>In our interpreter:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Expr::If { cond, then_branch, else_branch } =&gt; {
    let cond_val = self.eval_expr(cond)?;
    if let Value::Bool(b) = cond_val {
        let branch = if b { then_branch } else { else_branch };
        // Execute the chosen branch
        for stmt in branch {
            // ...
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="examples-2"><a class="header" href="#examples-2">Examples</a></h3>
<pre><code class="language-python">def abs(x) {
    if (x &lt; 0) {
        return x * -1
    } else {
        return x
    }
}

abs(-5)     # 5
abs(3)      # 3
</code></pre>
<pre><code class="language-python">def max(a, b) {
    if (a &gt; b) {
        return a
    } else {
        return b
    }
}

max(10, 20)  # 20
</code></pre>
<h2 id="loops-while"><a class="header" href="#loops-while">Loops: While</a></h2>
<p>The <code>while</code> loop repeats while a condition is true:</p>
<pre><code class="language-python">x = 0
while (x &lt; 5) {
    x = x + 1
}
x           # 5
</code></pre>
<h3 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Expr::While { cond, body } =&gt; {
    loop {
        let cond_val = self.eval_expr(cond)?;
        if let Value::Bool(b) = cond_val {
            if !b { break; }
            // Execute body
            for stmt in body {
                // ...
            }
        }
    }
    Ok(Value::Unit)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="examples-3"><a class="header" href="#examples-3">Examples</a></h3>
<pre><code class="language-python"># Sum 1 to 10
sum = 0
i = 1
while (i &lt;= 10) {
    sum = sum + i
    i = i + 1
}
sum         # 55
</code></pre>
<pre><code class="language-python"># Iterative factorial
def factorial(n) {
    result = 1
    while (n &gt; 1) {
        result = result * n
        n = n - 1
    }
    return result
}

factorial(5)  # 120
</code></pre>
<h2 id="control-flow-in-functions"><a class="header" href="#control-flow-in-functions">Control Flow in Functions</a></h2>
<p>Control flow becomes powerful when combined with functions:</p>
<pre><code class="language-python">def countdown(n) {
    while (n &gt; 0) {
        n = n - 1
    }
    return n
}

def fizzbuzz_check(n) {
    if (n % 3 == 0) {
        return 1    # Divisible by 3
    } else {
        if (n % 5 == 0) {
            return 2    # Divisible by 5
        } else {
            return 0    # Neither
        }
    }
}
</code></pre>
<h2 id="return-in-loops"><a class="header" href="#return-in-loops">Return in Loops</a></h2>
<p><code>return</code> exits the function immediately, even from inside a loop:</p>
<pre><code class="language-python">def find_first_even(n) {
    i = 1
    while (i &lt;= n) {
        if (i % 2 == 0) {
            return i    # Exit immediately
        }
        i = i + 1
    }
    return 0    # Not found
}

find_first_even(5)  # 2
</code></pre>
<p>With control flow in place, we’re ready for the ultimate test: <a href="02_firstlang/./recursion.html">recursion</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursion-1"><a class="header" href="#recursion-1">Recursion</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Recursion_(computer_science)">Recursion</a> is when a function calls itself. It’s a powerful technique for solving problems that have a recursive structure.</p>
<h2 id="the-key-insight"><a class="header" href="#the-key-insight">The Key Insight</a></h2>
<p>A recursive function has two parts:</p>
<ol>
<li><strong>Base case</strong> - A condition where we return directly (no recursion)</li>
<li><strong>Recursive case</strong> - We call ourselves with a “smaller” problem</li>
</ol>
<p>Every recursive function must have both. Without a base case, the recursion never stops (infinite loop). Without a recursive case, there is no recursion at all.</p>
<h2 id="classic-example-factorial"><a class="header" href="#classic-example-factorial">Classic Example: Factorial</a></h2>
<p>The <a href="https://en.wikipedia.org/wiki/Factorial">factorial function</a> is the “hello world” of recursion. Mathematically:</p>
<p>$$ n! = n \times (n-1) \times (n-2) \times \cdots \times 1 $$</p>
<p>Or recursively:</p>
<p>$$
n! = \begin{cases}
1 &amp; \text{if } n \leq 1 \\
n \times (n-1)! &amp; \text{otherwise}
\end{cases}
$$</p>
<pre><code class="language-python">def factorial(n) {
    if (n &lt;= 1) {
        return 1        # Base case
    } else {
        return n * factorial(n - 1)  # Recursive case
    }
}

factorial(5)  # 5 * 4 * 3 * 2 * 1 = 120
</code></pre>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<p>Let’s trace <code>factorial(4)</code>:</p>
<pre><code>factorial(4)
  → 4 * factorial(3)
      → 3 * factorial(2)
          → 2 * factorial(1)
              → 1  (base case!)
          ← 2 * 1 = 2
      ← 3 * 2 = 6
  ← 4 * 6 = 24
</code></pre>
<h2 id="the-call-stack-1"><a class="header" href="#the-call-stack-1">The Call Stack</a></h2>
<p>Each recursive call creates a new <a href="https://en.wikipedia.org/wiki/Call_stack">stack frame</a>:</p>
<pre><code>factorial(4) → frame: {n: 4}
factorial(3) → frame: {n: 3}
factorial(2) → frame: {n: 2}
factorial(1) → frame: {n: 1}  ← hits base case, starts returning
</code></pre>
<p>This is why our interpreter needs a call stack - to keep track of each call’s local variables.</p>
<h2 id="why-recursion-works-in-firstlang"><a class="header" href="#why-recursion-works-in-firstlang">Why Recursion Works in Firstlang</a></h2>
<p>Our interpreter properly handles recursion because:</p>
<ol>
<li><strong>Functions are stored globally</strong> - <code>factorial</code> can look itself up</li>
<li><strong>Each call gets its own frame</strong> - Local <code>n</code> is different in each call</li>
<li><strong>Return propagates values</strong> - Results bubble up through the stack</li>
</ol>
<h2 id="more-examples"><a class="header" href="#more-examples">More Examples</a></h2>
<h3 id="sum-of-numbers"><a class="header" href="#sum-of-numbers">Sum of Numbers</a></h3>
<pre><code class="language-python">def sum_to(n) {
    if (n &lt;= 0) {
        return 0
    } else {
        return n + sum_to(n - 1)
    }
}

sum_to(5)  # 5 + 4 + 3 + 2 + 1 + 0 = 15
</code></pre>
<h3 id="power-function"><a class="header" href="#power-function">Power Function</a></h3>
<pre><code class="language-python">def power(base, exp) {
    if (exp == 0) {
        return 1
    } else {
        return base * power(base, exp - 1)
    }
}

power(2, 10)  # 1024
</code></pre>
<h3 id="mutual-recursion"><a class="header" href="#mutual-recursion">Mutual Recursion</a></h3>
<p>Functions can call each other recursively. This is called <a href="https://en.wikipedia.org/wiki/Mutual_recursion">mutual recursion</a>:</p>
<pre><code class="language-python">def is_even(n) {
    if (n == 0) {
        return true
    } else {
        return is_odd(n - 1)
    }
}

def is_odd(n) {
    if (n == 0) {
        return false
    } else {
        return is_even(n - 1)
    }
}

is_even(4)  # true
is_odd(7)   # true
</code></pre>
<h2 id="a-note-on-stack-overflow"><a class="header" href="#a-note-on-stack-overflow">A Note on Stack Overflow</a></h2>
<p>Recursion uses memory for each call. Very deep recursion can cause a <a href="https://en.wikipedia.org/wiki/Stack_overflow">stack overflow</a>:</p>
<pre><code class="language-python">factorial(100000)  # Too deep! Runs out of stack space.
</code></pre>
<p>The iterative version using a <code>while</code> loop (from the <a href="02_firstlang/./control_flow.html">control flow</a> chapter) does not have this problem. Some languages optimize <a href="https://en.wikipedia.org/wiki/Tail_call">tail calls</a> to avoid this issue.</p>
<h2 id="the-ultimate-test-fibonacci"><a class="header" href="#the-ultimate-test-fibonacci">The Ultimate Test: Fibonacci</a></h2>
<p>Now we’re ready for <a href="02_firstlang/./fibonacci.html">Fibonacci</a> - the culmination of everything we’ve built!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-the-repl"><a class="header" href="#building-the-repl">Building the REPL</a></h1>
<p>A REPL (Read-Eval-Print Loop) is an interactive environment for your language. It lets users type expressions and see results immediately.</p>
<h2 id="the-basic-loop"><a class="header" href="#the-basic-loop">The Basic Loop</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn repl() {
    let mut interpreter = Interpreter::new();

    loop {
        // Read
        print!("&gt;&gt;&gt; ");
        let line = read_line();

        // Eval
        let program = parse(&amp;line)?;
        let result = interpreter.run(&amp;program)?;

        // Print
        println!("{}", result);

        // Loop (back to Read)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="persistent-state"><a class="header" href="#persistent-state">Persistent State</a></h2>
<p>The key insight is that we use <strong>one interpreter</strong> across all inputs. This means:</p>
<ul>
<li>Variables defined in one line are available in the next</li>
<li>Functions stay defined for the session</li>
</ul>
<pre><code>&gt;&gt;&gt; x = 42
&gt;&gt;&gt; y = x + 8
&gt;&gt;&gt; y
50
&gt;&gt;&gt; def double(n) { return n * 2 }
&gt;&gt;&gt; double(y)
100
</code></pre>
<h2 id="running-the-repl"><a class="header" href="#running-the-repl">Running the REPL</a></h2>
<pre><code class="language-bash">cargo run
</code></pre>
<pre><code>Firstlang REPL v0.1.0
Type expressions to evaluate, or 'quit' to exit.

&gt;&gt;&gt; 1 + 2
3
&gt;&gt;&gt; def fib(n) { if (n &lt; 2) { return n } else { return fib(n-1) + fib(n-2) } }
&gt;&gt;&gt; fib(10)
55
&gt;&gt;&gt; quit
Goodbye!
</code></pre>
<h2 id="multi-line-input"><a class="header" href="#multi-line-input">Multi-line Input</a></h2>
<p>The REPL supports multi-line input by detecting unclosed brackets. When you have unclosed <code>{</code>, <code>(</code>, or <code>[</code>, the REPL shows a continuation prompt (<code>...</code>) and waits for more input:</p>
<pre><code>&gt;&gt;&gt; def factorial(n) {
...     if (n &lt;= 1) {
...         return 1
...     } else {
...         return n * factorial(n - 1)
...     }
... }
&gt;&gt;&gt; factorial(5)
120
</code></pre>
<p>This is implemented by counting bracket depth:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Count unmatched opening brackets in a string
fn bracket_depth(s: &amp;str) -&gt; i32 {
    let mut depth = 0;
    let mut in_string = false;

    for c in s.chars() {
        if c == '"' { in_string = !in_string; }
        if !in_string {
            match c {
                '{' | '(' | '[' =&gt; depth += 1,
                '}' | ')' | ']' =&gt; depth -= 1,
                _ =&gt; {}
            }
        }
    }
    depth
}
<span class="boring">}</span></code></pre></pre>
<p>When <code>bracket_depth</code> is positive, we keep reading lines until all brackets are closed.</p>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>The REPL catches errors and keeps running:</p>
<pre><code>&gt;&gt;&gt; undefined_var
Runtime error: Undefined variable: undefined_var
&gt;&gt;&gt; 1 / 0
Runtime error: Division by zero
&gt;&gt;&gt; 1 + 2
3
</code></pre>
<p>The REPL is your best friend for experimenting with the language! Try computing <a href="02_firstlang/./fibonacci.html">Fibonacci</a> interactively.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="computing-fibonacci"><a class="header" href="#computing-fibonacci">Computing Fibonacci</a></h1>
<p>This is it - the culmination of everything we’ve built! Let’s compute the <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci sequence</a>.</p>
<h2 id="the-fibonacci-sequence"><a class="header" href="#the-fibonacci-sequence">The Fibonacci Sequence</a></h2>
<p>The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the previous two:</p>
<pre><code>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...
</code></pre>
<p>Mathematically:</p>
<p>$$
\text{fib}(n) = \begin{cases}
0 &amp; \text{if } n = 0 \\
1 &amp; \text{if } n = 1 \\
\text{fib}(n-1) + \text{fib}(n-2) &amp; \text{if } n &gt; 1
\end{cases}
$$</p>
<p>This sequence appears throughout nature - in flower petals, pine cones, and the spiral of shells. It is closely related to the <a href="https://en.wikipedia.org/wiki/Golden_ratio">golden ratio</a>.</p>
<h2 id="recursive-implementation"><a class="header" href="#recursive-implementation">Recursive Implementation</a></h2>
<p>The mathematical definition translates directly to code:</p>
<pre><code class="language-python">def fib(n) {
    if (n &lt; 2) {
        return n
    } else {
        return fib(n - 1) + fib(n - 2)
    }
}

fib(10)  # = 55
</code></pre>
<p>This is beautiful in its simplicity, but let’s trace through what happens when we call <code>fib(4)</code>:</p>
<pre><code>fib(4)
├── fib(3)
│   ├── fib(2)
│   │   ├── fib(1) → 1
│   │   └── fib(0) → 0
│   │   └── 1 + 0 = 1
│   └── fib(1) → 1
│   └── 1 + 1 = 2
└── fib(2)
    ├── fib(1) → 1
    └── fib(0) → 0
    └── 1 + 0 = 1
└── 2 + 1 = 3
</code></pre>
<p>Each call creates a new stack frame in our interpreter, and when the function returns, we pop the frame and continue with the result.</p>
<h2 id="why-this-works"><a class="header" href="#why-this-works">Why This Works</a></h2>
<p>Our interpreter properly handles recursion because:</p>
<ol>
<li><strong>Call Stack</strong> - Each function call pushes a new environment frame</li>
<li><strong>Local Variables</strong> - Parameters <code>n</code> are local to each call</li>
<li><strong>Return Values</strong> - We propagate return values up the call stack</li>
</ol>
<h2 id="iterative-alternative"><a class="header" href="#iterative-alternative">Iterative Alternative</a></h2>
<p>For comparison, here’s an iterative version (also works in Firstlang):</p>
<pre><code class="language-python">def fib_iter(n) {
    if (n &lt; 2) {
        return n
    } else {
        a = 0
        b = 1
        i = 2
        while (i &lt;= n) {
            temp = a + b
            a = b
            b = temp
            i = i + 1
        }
        return b
    }
}

fib_iter(10)  # = 55
</code></pre>
<p>The iterative version is more efficient ($O(n)$ vs $O(2^n)$ - see <a href="https://en.wikipedia.org/wiki/Big_O_notation">Big O notation</a>), but the recursive version is more elegant and demonstrates the power of our language.</p>
<h2 id="running-it"><a class="header" href="#running-it">Running It</a></h2>
<p>Save to <code>fibonacci.fl</code> and run:</p>
<pre><code class="language-bash">cargo run -- fibonacci.fl
55
</code></pre>
<p>Or in the REPL:</p>
<pre><code>&gt;&gt;&gt; def fib(n) {
...     if (n &lt; 2) { return n } else { return fib(n - 1) + fib(n - 2) }
... }
&gt;&gt;&gt; fib(10)
55
&gt;&gt;&gt; fib(20)
6765
</code></pre>
<h2 id="performance-note"><a class="header" href="#performance-note">Performance Note</a></h2>
<p>Our <a href="https://en.wikipedia.org/wiki/Interpreter_(computing)#Abstract_syntax_tree_interpreters">tree-walking interpreter</a> is not optimized. Computing <code>fib(35)</code> might take several seconds due to exponential complexity and interpretation overhead.</p>
<p>In the next part of the book (<a href="02_firstlang/../03_secondlang/intro.html">Secondlang</a>), we’ll add types and compile to native code via LLVM - making <code>fib(35)</code> nearly instant!</p>
<h2 id="what-weve-built"><a class="header" href="#what-weve-built">What We’ve Built</a></h2>
<p>Congratulations! You’ve built a complete interpreted programming language that can:</p>
<ul>
<li>Parse Python-like syntax</li>
<li>Handle variables and scoping</li>
<li>Define and call functions</li>
<li>Support recursion with proper stack frames</li>
<li>Execute control flow (if/else, while)</li>
<li>Compute Fibonacci recursively</li>
</ul>
<p>The Firstlang interpreter is about <strong>500 lines of Rust</strong> - not bad for a real programming language!</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Ready for more? In <a href="02_firstlang/../03_secondlang/intro.html">Part III: Secondlang</a>, we’ll add:</p>
<ul>
<li><a href="02_firstlang/../03_secondlang/annotations.html">Type annotations</a> (<code>def fib(n: int) -&gt; int</code>)</li>
<li><a href="02_firstlang/../03_secondlang/inference.html">Type inference</a></li>
<li><a href="02_firstlang/../03_secondlang/codegen.html">LLVM code generation</a></li>
<li><a href="02_firstlang/../03_secondlang/jit_fibonacci.html">JIT compilation</a> to native code</li>
</ul>
<p>The same Fibonacci function, but compiled to machine code!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secondlang"><a class="header" href="#secondlang">Secondlang</a></h1>
<p>In Part II, we built <a href="03_secondlang/../02_firstlang/intro.html">Firstlang</a>, an interpreted language with functions, recursion, and control flow. Now we take the next step: adding a <em>type system</em> and compiling to native code using LLVM.</p>
<h2 id="what-changes-from-firstlang"><a class="header" href="#what-changes-from-firstlang">What Changes from Firstlang?</a></h2>
<p>The transition from Firstlang to Secondlang illustrates a key insight in language design: <strong>types are primarily a semantic addition, not a syntactic one</strong>. The grammar changes are minimal, but the compiler architecture changes significantly.</p>
<h3 id="grammar-7-lines-added"><a class="header" href="#grammar-7-lines-added">Grammar: 7 Lines Added</a></h3>
<p>Firstlang’s function definition:</p>
<pre><code class="language-text">Function = { "def" ~ Identifier ~ "(" ~ Params? ~ ")" ~ Block }
Params = _{ Identifier ~ ("," ~ Identifier)* }
</code></pre>
<p>Secondlang’s function definition:</p>
<pre><code class="language-text">Function = { "def" ~ Identifier ~ "(" ~ TypedParams? ~ ")" ~ ReturnType? ~ Block }
TypedParams = _{ TypedParam ~ ("," ~ TypedParam)* }
TypedParam = { Identifier ~ ":" ~ Type }
ReturnType = { "-&gt;" ~ Type }
Type = { IntType | BoolType }
IntType = { "int" }
BoolType = { "bool" }
</code></pre>
<p>The only syntactic change is <code>param</code> becomes <code>param: type</code> and we add <code>-&gt; return_type</code>. Everything else (expressions, statements, control flow) remains identical.</p>
<h3 id="compiler-two-new-phases"><a class="header" href="#compiler-two-new-phases">Compiler: Two New Phases</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Phase</th><th>Firstlang</th><th>Secondlang</th></tr></thead><tbody>
<tr><td>Parsing</td><td>Source → AST</td><td>Source → Typed AST</td></tr>
<tr><td>Type Checking</td><td>None</td><td>AST → Typed AST (types resolved)</td></tr>
<tr><td>Execution</td><td>Tree-walking interpreter</td><td>LLVM code generation → JIT</td></tr>
</tbody></table>
</div>
<p>The type checker is the major new component. It walks the AST, infers types for expressions, and catches errors like <code>1 + true</code> at compile time instead of runtime.</p>
<h2 id="why-types-enable-compilation"><a class="header" href="#why-types-enable-compilation">Why Types Enable Compilation</a></h2>
<p>Without types, the interpreter must check types at runtime for every operation:</p>
<pre><code class="language-python"># Firstlang interpreter
def eval_binary(left, right, op):
    if type(left) != type(right):
        raise TypeError("...")
    if op == "+" and isinstance(left, int):
        return left + right
    # ... many more checks
</code></pre>
<p>With static types, we know at compile time that <code>a</code> is an <code>int</code> and <code>b</code> is an <code>int</code>, so <code>a + b</code> is a single CPU instruction:</p>
<pre><code class="language-llvm">%add = add i64 %a, %b
</code></pre>
<p>No runtime checks, no type dispatch, just a direct machine instruction.</p>
<h2 id="feature-comparison"><a class="header" href="#feature-comparison">Feature Comparison</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Firstlang</th><th>Secondlang</th></tr></thead><tbody>
<tr><td>Type System</td><td>Dynamic (runtime)</td><td>Static (compile-time)</td></tr>
<tr><td>Type Annotations</td><td>None</td><td><code>x: int</code>, <code>-&gt; int</code></td></tr>
<tr><td>Type Errors</td><td>Runtime crash</td><td>Compile-time error</td></tr>
<tr><td>Execution</td><td>Tree-walking interpreter</td><td>LLVM JIT native code</td></tr>
<tr><td>Optimizations</td><td>None</td><td>Constant folding, algebraic simplification</td></tr>
</tbody></table>
</div>
<h2 id="syntax-comparison"><a class="header" href="#syntax-comparison">Syntax Comparison</a></h2>
<p>Firstlang (untyped):</p>
<pre><code class="language-python">def fib(n) {
    if (n &lt; 2) {
        return n
    } else {
        return fib(n - 1) + fib(n - 2)
    }
}
fib(10)
</code></pre>
<p>Secondlang (typed):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>def fib(n: int) -&gt; int {
    if (n &lt; 2) {
        return n
    } else {
        return fib(n - 1) + fib(n - 2)
    }
}
fib(10)
<span class="boring">}</span></code></pre></pre>
<p>The programs are nearly identical. Type annotations are the only difference, but they unlock compile-time safety and native code generation.</p>
<h2 id="project-structure-1"><a class="header" href="#project-structure-1">Project Structure</a></h2>
<pre><code>secondlang/
├── Cargo.toml
├── src/
│   ├── lib.rs           # Library exports
│   ├── main.rs          # CLI entry point
│   ├── grammar.pest     # PEG grammar with types
│   ├── parser.rs        # Parser → Typed AST
│   ├── ast.rs           # Typed AST definitions
│   ├── types.rs         # Type system
│   ├── typeck.rs        # Type checker and inference
│   ├── visitor.rs       # AST visitors and optimizations
│   └── codegen.rs       # LLVM code generation
├── examples/
│   ├── fibonacci.sl
│   └── factorial.sl
└── tests/
    └── integration_tests.rs
</code></pre>
<p>Compare to <a href="03_secondlang/../02_firstlang/intro.html#project-structure">Firstlang’s structure</a>:</p>
<pre><code>firstlang/
├── src/
│   ├── grammar.pest     # Same structure, fewer rules
│   ├── parser.rs        # Simpler: no type handling
│   ├── ast.rs           # Simpler: no TypedExpr
│   └── interpreter.rs   # Tree-walking, no codegen
</code></pre>
<p>The new modules (<code>types.rs</code>, <code>typeck.rs</code>, <code>visitor.rs</code>, <code>codegen.rs</code>) represent the additional complexity that types bring, but also the power they unlock.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>LLVM is required. Check your version with <code>llvm-config --version</code> and update <code>Cargo.toml</code> accordingly:</p>
<ul>
<li>LLVM 20.x: <code>features = ["llvm20-1"]</code></li>
<li>LLVM 19.x: <code>features = ["llvm19-1"]</code></li>
<li>LLVM 18.x: <code>features = ["llvm18-1"]</code></li>
</ul>
<p>Secondlang also requires Rust nightly due to inkwell’s dependency on edition 2024.</p>
<pre><code class="language-bash">rustup toolchain install nightly
</code></pre>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<pre><code class="language-bash">cd secondlang

# Run Fibonacci
rustup run nightly cargo run -- examples/fibonacci.sl

# Show LLVM IR
rustup run nightly cargo run -- --ir examples/fibonacci.sl

# Type check only
rustup run nightly cargo run -- --check examples/fibonacci.sl
</code></pre>
<h2 id="outline-1"><a class="header" href="#outline-1">Outline</a></h2>
<p>In the following chapters, we build Secondlang step by step:</p>
<ol>
<li><a href="03_secondlang/why_types.html">Why Types Matter</a> - Benefits of static typing</li>
<li><a href="03_secondlang/annotations.html">Type Annotations</a> - Grammar and parsing changes</li>
<li><a href="03_secondlang/inference.html">Type Inference</a> - Deducing types automatically</li>
<li><a href="03_secondlang/optimizations.html">AST Optimizations</a> - Visitor pattern and optimization passes</li>
<li><a href="03_secondlang/ir.html">From AST to IR</a> - LLVM intermediate representation</li>
<li><a href="03_secondlang/codegen.html">LLVM Code Generation</a> - Native code generation</li>
<li><a href="03_secondlang/jit_fibonacci.html">JIT Compiling Fibonacci</a> - Putting it all together</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-types-matter"><a class="header" href="#why-types-matter">Why Types Matter</a></h1>
<p>Before we start adding types to our language, let us take a moment to understand <em>why</em> we would want types in the first place. After all, <a href="03_secondlang/../02_firstlang/intro.html">Firstlang</a> works just fine without them.</p>
<h2 id="the-problem-runtime-surprises"><a class="header" href="#the-problem-runtime-surprises">The Problem: Runtime Surprises</a></h2>
<p>In Firstlang, we can write code like this:</p>
<pre><code class="language-python">def add(a, b) {
    return a + b
}

add(1, 2)      # works fine, returns 3
add(10, 20)    # works fine, returns 30
add(1, true)   # crashes at runtime!
</code></pre>
<p>The third call <code>add(1, true)</code> will crash when the program runs. But here is the problem: <em>we do not know about this bug until we actually run the program and hit that specific line of code</em>.</p>
<p>In a small program, this might be okay. But imagine a large program with thousands of lines. The buggy code might be in a rarely-used feature. You deploy your program, and months later, a user triggers that code path and the program crashes. Not good.</p>
<h2 id="the-solution-catch-errors-early"><a class="header" href="#the-solution-catch-errors-early">The Solution: Catch Errors Early</a></h2>
<p>With types, we tell the compiler <em>what kind of values</em> each variable can hold:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>def add(a: int, b: int) -&gt; int {
    return a + b
}

add(1, true)  # Error at COMPILE time: expected int, got bool
<span class="boring">}</span></code></pre></pre>
<p>Now the compiler catches the bug <em>before</em> the program even runs. We know about the problem immediately, not months later in production.</p>
<p>Think of types as a <em>contract</em>. When we write <code>a: int</code>, we are promising that <code>a</code> will always be an integer. The compiler checks that we keep our promises.</p>
<h2 id="static-vs-dynamic-typing"><a class="header" href="#static-vs-dynamic-typing">Static vs Dynamic Typing</a></h2>
<p>Programming languages are divided into two camps:</p>
<div class="table-wrapper"><table><thead><tr><th>Approach</th><th>When types are checked</th><th>Examples</th></tr></thead><tbody>
<tr><td><strong><a href="https://en.wikipedia.org/wiki/Type_system#Static_type_checking">Static typing</a></strong></td><td>At compile time (before running)</td><td>Rust, C, Java, Haskell</td></tr>
<tr><td><strong><a href="https://en.wikipedia.org/wiki/Type_system#Dynamic_type_checking">Dynamic typing</a></strong></td><td>At runtime (while running)</td><td>Python, JavaScript, Ruby</td></tr>
</tbody></table>
</div>
<p>Firstlang is dynamically typed. Secondlang is statically typed.</p>
<p>Both approaches have trade-offs:</p>
<ul>
<li><strong>Static</strong>: Catches more bugs early, enables better performance, but requires more upfront type annotations</li>
<li><strong>Dynamic</strong>: More flexible, faster to prototype, but bugs can hide until runtime</li>
</ul>
<h2 id="types-enable-fast-code"><a class="header" href="#types-enable-fast-code">Types Enable Fast Code</a></h2>
<p>There is another benefit to types: <strong>performance</strong>.</p>
<p>Consider this function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>def square(x: int) -&gt; int {
    return x * x
}
<span class="boring">}</span></code></pre></pre>
<p>The compiler knows that <code>x</code> is always a 64-bit integer. It knows the result is always a 64-bit integer. So it can generate a <em>single CPU instruction</em> for the multiplication:</p>
<pre><code class="language-asm">imul rax, rax   ; multiply rax by itself
</code></pre>
<p>Without types, the interpreter has to do a lot of work at runtime:</p>
<ol>
<li>Check what type <code>x</code> is</li>
<li>Look up the multiplication operation for that type</li>
<li>Check if the operands are compatible</li>
<li>Handle potential type errors</li>
<li>Finally, do the multiplication</li>
</ol>
<p>All this checking adds up. A statically typed language can be 10x to 100x faster than a dynamically typed one for number-crunching tasks.</p>
<p>This is why <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">JIT compilers</a> like V8 (JavaScript) and PyPy (Python) spend so much effort on <em>type speculation</em> - guessing what types values have so they can generate fast code.</p>
<h2 id="our-type-system"><a class="header" href="#our-type-system">Our Type System</a></h2>
<p>We will keep things simple. Secondlang has two basic types:</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>What it holds</th><th>Examples</th></tr></thead><tbody>
<tr><td><code>int</code></td><td>64-bit signed integer</td><td><code>42</code>, <code>-1</code>, <code>0</code></td></tr>
<tr><td><code>bool</code></td><td>Boolean value</td><td><code>true</code>, <code>false</code></td></tr>
</tbody></table>
</div>
<p>These are sometimes called <a href="https://en.wikipedia.org/wiki/Primitive_data_type">primitive types</a>.</p>
<p>Functions also have types. A function’s type describes what it takes in and what it produces:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>def add(a: int, b: int) -&gt; int { ... }
<span class="boring">Type: (int, int) -&gt; int
</span><span class="boring">"Takes two ints, returns an int"
</span>
def isPositive(n: int) -&gt; bool { ... }
<span class="boring">Type: (int) -&gt; bool
</span><span class="boring">"Takes an int, returns a bool"
</span><span class="boring">}</span></code></pre></pre>
<p>This notation <code>(int, int) -&gt; int</code> is called a <a href="https://en.wikipedia.org/wiki/Function_type">function type</a>.</p>
<h2 id="type-inference-the-best-of-both-worlds"><a class="header" href="#type-inference-the-best-of-both-worlds">Type Inference: The Best of Both Worlds</a></h2>
<p>You might worry that adding types means writing <code>int</code> everywhere, making code verbose. But we can be smarter.</p>
<p><em><a href="https://en.wikipedia.org/wiki/Type_inference">Type inference</a></em> means the compiler figures out types when it can:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>def factorial(n: int) -&gt; int {
    result = 1        # compiler infers: result is int
    i = 1             # compiler infers: i is int
    while (i &lt;= n) {
        result = result * i
        i = i + 1
    }
    return result
}
<span class="boring">}</span></code></pre></pre>
<p>We write the types on function parameters and return values (the <em>boundaries</em>), and the compiler infers the rest. This gives us the safety of types without excessive verbosity. We cover this in detail in the <a href="03_secondlang/./inference.html">Type Inference</a> chapter.</p>
<h2 id="how-type-checking-works"><a class="header" href="#how-type-checking-works">How Type Checking Works</a></h2>
<p>Here is the high-level flow:</p>
<pre><code>Source Code: "def add(a: int, b: int) -&gt; int { return a + b }"
                              |
                          [Parser]
                              |
                Typed AST (some types are Unknown)
                              |
                        [Type Checker]
                              |
                Typed AST (all types filled in)
                              |
                      [Code Generator]
                              |
                          LLVM IR
                              |
                           [LLVM]
                              |
                        Native Code
</code></pre>
<p>The <a href="https://en.wikipedia.org/wiki/Parsing">parser</a> creates an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">AST</a> where some types are marked as <code>Unknown</code> (we do not know them yet). The type checker walks through the AST, figures out all the unknown types, and checks that everything is consistent. If something is wrong (like <code>1 + true</code>), it reports an error. If everything is okay, we have a fully-typed AST ready for code generation.</p>
<h2 id="implementation-2"><a class="header" href="#implementation-2">Implementation</a></h2>
<p>Our type system is defined in <code>types.rs</code>:</p>
<pre><code class="language-rust ignore">/// Types in our language
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Type {
    /// Integer type (64-bit signed)
    Int,
    /// Boolean type
    Bool,
    /// Function type: (param_types) -&gt; return_type
    Function { params: Vec&lt;Type&gt;, ret: Box&lt;Type&gt; },
    /// Unit type (for statements with no value)
    Unit,
    /// Unknown type (for type inference)
    Unknown,
}</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/secondlang/src/types.rs">secondlang/src/types.rs</a></p>
<p>Let us go through each variant:</p>
<ul>
<li><code>Int</code> - represents the <code>int</code> type (64-bit signed integer)</li>
<li><code>Bool</code> - represents the <code>bool</code> type (true/false)</li>
<li><code>Function</code> - represents a function type with parameter types and return type</li>
<li><code>Unit</code> - represents “no value” (like <code>void</code> in C or <code>()</code> in Rust)</li>
<li><code>Unknown</code> - a placeholder used during type inference</li>
</ul>
<p>The <code>Unknown</code> type is the key to type inference. When we parse <code>x = 1 + 2</code>, we do not know <code>x</code>’s type yet, so we mark it as <code>Unknown</code>. The type checker later figures out it must be <code>Int</code> (because <code>1 + 2</code> produces an <code>Int</code>).</p>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Type_system">Type system on Wikipedia</a> - overview of type system concepts</li>
<li><a href="https://en.wikipedia.org/wiki/Type_system#Static_and_dynamic_type_checking_in_practice">Static vs Dynamic Typing</a> - detailed comparison</li>
<li><a href="https://en.wikipedia.org/wiki/Strong_and_weak_typing">Strong and Weak Typing</a> - another dimension of type systems</li>
</ul>
<p>In the next chapter, we will see how to <a href="03_secondlang/./annotations.html">add type annotations to our grammar</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-annotations"><a class="header" href="#type-annotations">Type Annotations</a></h1>
<p>Now that we understand <a href="03_secondlang/./why_types.html">why we want types</a>, let us see <em>how</em> to add them to our language. The good news: the grammar changes are minimal. Most of the work happens in the <a href="03_secondlang/./inference.html">type checker</a>.</p>
<h2 id="what-changes-in-the-grammar"><a class="header" href="#what-changes-in-the-grammar">What Changes in the Grammar?</a></h2>
<p>Remember <a href="03_secondlang/../02_firstlang/syntax.html">Firstlang’s</a> function definition:</p>
<pre><code class="language-text">Function = { "def" ~ Identifier ~ "(" ~ Params? ~ ")" ~ Block }
Params = _{ Identifier ~ ("," ~ Identifier)* }
</code></pre>
<p>A function like <code>def add(a, b) { ... }</code> has parameters <code>a</code> and <code>b</code>, but we do not know their types.</p>
<p>In Secondlang, we add <a href="https://en.wikipedia.org/wiki/Type_signature">type annotations</a>:</p>
<pre><code class="language-text">Function = { "def" ~ Identifier ~ "(" ~ TypedParams? ~ ")" ~ ReturnType? ~ Block }
TypedParams = _{ TypedParam ~ ("," ~ TypedParam)* }
TypedParam = { Identifier ~ ":" ~ Type }
ReturnType = { "-&gt;" ~ Type }
</code></pre>
<p>Now we write <code>def add(a: int, b: int) -&gt; int { ... }</code>. The changes are:</p>
<ol>
<li>Parameters become <code>name: type</code> instead of just <code>name</code></li>
<li>Functions can have a return type <code>-&gt; type</code></li>
</ol>
<p>This syntax is similar to <a href="https://peps.python.org/pep-0484/">type hints in Python</a>, <a href="https://www.typescriptlang.org/">TypeScript</a>, and Rust.</p>
<p>We also need to define what a <code>Type</code> is:</p>
<pre><code class="language-text">Type = { IntType | BoolType }
IntType = { "int" }
BoolType = { "bool" }
</code></pre>
<p>That is it. Just these few lines enable static typing in our language.</p>
<h2 id="the-complete-grammar"><a class="header" href="#the-complete-grammar">The Complete Grammar</a></h2>
<p>Here is the full Secondlang grammar. Notice that <em>most of it is identical to Firstlang</em>. Only the rules involving declarations changed:</p>
<pre><code class="language-text">// Secondlang Grammar - A typed Python-like language
// Same syntax as Firstlang, but with type annotations

WHITESPACE = _{ " " | "\t" | NEWLINE }
COMMENT = _{ "#" ~ (!NEWLINE ~ ANY)* }

// Keywords
KEYWORD = @{ "def" | "if" | "else" | "while" | "true" | "false" | "return" | "int" | "bool" }

// Identifiers (variable/function names)
Identifier = @{ !KEYWORD ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// Types
Type = { IntType | BoolType }
IntType = { "int" }
BoolType = { "bool" }

// Program is a sequence of statements/expressions
Program = _{ SOI ~ Stmt* ~ EOI }

// Statements
Stmt = { Function | SimpleStmt }
SimpleStmt = _{ (Return | Assignment | Expr) }

// Function definition with types: def name(x: int, y: int) -&gt; int { body }
Function = { "def" ~ Identifier ~ "(" ~ TypedParams? ~ ")" ~ ReturnType? ~ Block }
TypedParams = _{ TypedParam ~ ("," ~ TypedParam)* }
TypedParam = { Identifier ~ ":" ~ Type }
ReturnType = { "-&gt;" ~ Type }

// Block: { statements }
Block = { "{" ~ Stmt* ~ "}" }

// Return statement
Return = { "return" ~ Expr }

// Assignment with optional type: x: int = 10  or  x = 10
Assignment = { Identifier ~ (":" ~ Type)? ~ "=" ~ Expr }

// Expressions (ordered by precedence - lowest to highest)
Expr = { Conditional | WhileLoop | Comparison }

// if (cond) { ... } else { ... }
Conditional = { "if" ~ "(" ~ Expr ~ ")" ~ Block ~ "else" ~ Block }

// while (cond) { ... }
WhileLoop = { "while" ~ "(" ~ Expr ~ ")" ~ Block }

// Comparison operators
Comparison = { Additive ~ (CompOp ~ Additive)* }
CompOp = { "&lt;=" | "&gt;=" | "&lt;" | "&gt;" | "==" | "!=" }

// Addition/Subtraction
Additive = { Multiplicative ~ (AddOp ~ Multiplicative)* }
AddOp = { "+" | "-" }

// Multiplication/Division
Multiplicative = { Unary ~ (MulOp ~ Unary)* }
MulOp = { "*" | "/" | "%" }

// Unary operators
Unary = { UnaryOp ~ Unary | Call }
UnaryOp = { "-" | "!" }

// Function call: name(args)
Call = { Primary ~ CallArgs* }
CallArgs = { "(" ~ Args? ~ ")" }
Args = _{ Expr ~ ("," ~ Expr)* }

// Primary expressions
Primary = _{ Literal | Identifier | "(" ~ Expr ~ ")" }

// Literals
Literal = { Bool | Int }
Int = @{ ASCII_DIGIT+ }
Bool = @{ "true" | "false" }

</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/secondlang/src/grammar.pest">secondlang/src/grammar.pest</a></p>
<p>Take a moment to compare this with <a href="03_secondlang/../02_firstlang/syntax.html">Firstlang’s grammar</a>. The expression rules (<code>Expr</code>, <code>Comparison</code>, <code>Additive</code>, etc.) are exactly the same. The only differences are in <code>Function</code>, <code>TypedParam</code>, <code>ReturnType</code>, <code>Type</code>, and <code>Assignment</code> (which now optionally accepts a type annotation). If the pest syntax looks unfamiliar, review the <a href="03_secondlang/../crash_course.html#peg-and-pest-syntax">PEG and pest Syntax</a> section.</p>
<h2 id="the-typed-ast"><a class="header" href="#the-typed-ast">The Typed AST</a></h2>
<p>In Firstlang, expressions were simple:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Expr {
    Int(i64),
    Bool(bool),
    Var(String),
    Binary { op: BinaryOp, left: Box&lt;Expr&gt;, right: Box&lt;Expr&gt; },
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>In Secondlang, every expression carries its type. This is sometimes called a <strong>decorated AST</strong> or <strong><a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">annotated AST</a></strong>:</p>
<pre><code class="language-rust ignore">/// A typed expression: expression + its inferred type
#[derive(Debug, Clone, PartialEq)]
pub struct TypedExpr {
    pub expr: Expr,
    pub ty: Type,
}

impl TypedExpr {
    pub fn new(expr: Expr, ty: Type) -&gt; Self {
        TypedExpr { expr, ty }
    }

    pub fn unknown(expr: Expr) -&gt; Self {
        TypedExpr {
            expr,
            ty: Type::Unknown,
        }
    }
}</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/secondlang/src/ast.rs">secondlang/src/ast.rs</a></p>
<p>The <code>TypedExpr</code> struct wraps an expression with its type. Let us understand the two constructors:</p>
<ul>
<li><code>TypedExpr::new(expr, ty)</code> - creates an expression with a <em>known</em> type</li>
<li><code>TypedExpr::unknown(expr)</code> - creates an expression with <code>Type::Unknown</code></li>
</ul>
<p>When we parse <code>1 + 2</code>, we do not yet know the type of the result. So we create:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>TypedExpr::unknown(Expr::Binary {
    op: BinaryOp::Add,
    left: Box::new(TypedExpr::unknown(Expr::Int(1))),
    right: Box::new(TypedExpr::unknown(Expr::Int(2))),
})
<span class="boring">}</span></code></pre></pre>
<p>All the types are <code>Unknown</code>. The type checker (next chapter) will fill them in.</p>
<h2 id="statements-with-types"><a class="header" href="#statements-with-types">Statements with Types</a></h2>
<p>Statements also include type information:</p>
<pre><code class="language-rust ignore">/// Statements in our language
#[derive(Debug, Clone, PartialEq)]
pub enum Stmt {
    /// Function definition with types
    Function {
        name: String,
        params: Vec&lt;(String, Type)&gt;,
        return_type: Type,
        body: Vec&lt;Stmt&gt;,
    },
    /// Return statement
    Return(TypedExpr),
    /// Assignment with optional type annotation
    Assignment {
        name: String,
        type_ann: Option&lt;Type&gt;,
        value: TypedExpr,
    },
    /// Expression statement
    Expr(TypedExpr),
}</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/secondlang/src/ast.rs">secondlang/src/ast.rs</a></p>
<p>Notice the differences from Firstlang:</p>
<ul>
<li><code>Function</code> now has <code>params: Vec&lt;(String, Type)&gt;</code> instead of <code>params: Vec&lt;String&gt;</code></li>
<li><code>Function</code> now has a <code>return_type: Type</code> field</li>
<li><code>Assignment</code> now has an optional <code>type_ann: Option&lt;Type&gt;</code> for explicit type annotations</li>
</ul>
<h2 id="the-expression-enum"><a class="header" href="#the-expression-enum">The Expression Enum</a></h2>
<pre><code class="language-rust ignore">/// Expressions in our language
#[derive(Debug, Clone, PartialEq)]
pub enum Expr {
    /// Integer literal
    Int(i64),
    /// Boolean literal
    Bool(bool),
    /// Variable reference
    Var(String),
    /// Unary operation
    Unary { op: UnaryOp, expr: Box&lt;TypedExpr&gt; },
    /// Binary operation
    Binary {
        op: BinaryOp,
        left: Box&lt;TypedExpr&gt;,
        right: Box&lt;TypedExpr&gt;,
    },
    /// Function call
    Call { name: String, args: Vec&lt;TypedExpr&gt; },
    /// Conditional
    If {
        cond: Box&lt;TypedExpr&gt;,
        then_branch: Vec&lt;Stmt&gt;,
        else_branch: Vec&lt;Stmt&gt;,
    },
    /// While loop
    While {
        cond: Box&lt;TypedExpr&gt;,
        body: Vec&lt;Stmt&gt;,
    },
    /// Block
    Block(Vec&lt;Stmt&gt;),
}</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/secondlang/src/ast.rs">secondlang/src/ast.rs</a></p>
<p>This looks almost identical to Firstlang. The key difference is that child expressions are <code>Box&lt;TypedExpr&gt;</code> instead of <code>Box&lt;Expr&gt;</code>. Every sub-expression carries its type.</p>
<h2 id="parsing-example"><a class="header" href="#parsing-example">Parsing Example</a></h2>
<p>Let us trace through parsing <code>def add(a: int, b: int) -&gt; int { return a + b }</code>:</p>
<ol>
<li>
<p><strong><code>Function</code> rule matches</strong> - we have <code>def</code>, an identifier, parameters, return type, and a block</p>
</li>
<li>
<p><strong>Parse function name</strong> - <code>Identifier</code> matches <code>add</code></p>
</li>
<li>
<p><strong>Parse parameters</strong> - <code>TypedParams</code> matches <code>a: int, b: int</code></p>
<ul>
<li>First <code>TypedParam</code>: <code>a: int</code> → <code>("a", Type::Int)</code></li>
<li>Second <code>TypedParam</code>: <code>b: int</code> → <code>("b", Type::Int)</code></li>
</ul>
</li>
<li>
<p><strong>Parse return type</strong> - <code>ReturnType</code> matches <code>-&gt; int</code> → <code>Type::Int</code></p>
</li>
<li>
<p><strong>Parse body</strong> - <code>Block</code> matches <code>{ return a + b }</code></p>
<ul>
<li><code>Return</code> statement with expression <code>a + b</code></li>
<li>The expression is parsed as <code>TypedExpr::unknown(Expr::Binary { ... })</code></li>
</ul>
</li>
</ol>
<p>The final AST looks like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Stmt::Function {
    name: "add".to_string(),
    params: vec![
        ("a".to_string(), Type::Int),
        ("b".to_string(), Type::Int),
    ],
    return_type: Type::Int,
    body: vec![
        Stmt::Return(TypedExpr {
            expr: Expr::Binary {
                op: BinaryOp::Add,
                left: Box::new(TypedExpr { expr: Expr::Var("a"), ty: Type::Unknown }),
                right: Box::new(TypedExpr { expr: Expr::Var("b"), ty: Type::Unknown }),
            },
            ty: Type::Unknown,  // &lt;-- filled in by type checker
        })
    ],
}
<span class="boring">}</span></code></pre></pre>
<p>Notice that all expression types are <code>Unknown</code>. The type checker will walk through this AST and fill in <code>Type::Int</code> everywhere.</p>
<p>In the next chapter, we will implement the <a href="03_secondlang/./inference.html">type checker</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h1>
<p>In the <a href="03_secondlang/./annotations.html">previous chapter</a>, we saw that the parser creates an AST with many <code>Type::Unknown</code> values. The type checker’s job is to figure out what those unknown types should be. This process is called <strong><a href="https://en.wikipedia.org/wiki/Type_inference">type inference</a></strong>.</p>
<h2 id="what-kind-of-type-inference"><a class="header" href="#what-kind-of-type-inference">What Kind of Type Inference?</a></h2>
<p>There are different approaches to type inference:</p>
<div class="table-wrapper"><table><thead><tr><th>Approach</th><th>Used By</th><th>Polymorphism</th><th>Complexity</th></tr></thead><tbody>
<tr><td><strong><a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">Hindley-Milner</a></strong></td><td>Haskell, ML, OCaml</td><td>Full parametric</td><td>High</td></tr>
<tr><td><strong><a href="https://en.wikipedia.org/wiki/Type_inference#Local_type_inference">Local Type Inference</a></strong></td><td>TypeScript, Go, Rust, Swift</td><td>Limited</td><td>Low</td></tr>
<tr><td><strong>Bidirectional Type Checking</strong></td><td>Scala, Agda</td><td>Configurable</td><td>Medium</td></tr>
</tbody></table>
</div>
<p>We use <strong>local type inference</strong> (also called “flow-based” inference). This is simpler than Hindley-Milner but covers the common cases. The key difference:</p>
<ul>
<li><strong>Hindley-Milner</strong>: Can infer polymorphic types like <code>fn identity&lt;T&gt;(x: T) -&gt; T</code> without any annotations</li>
<li><strong>Local inference</strong>: Requires type annotations at function boundaries; infers types <em>within</em> function bodies</li>
</ul>
<p>Our approach is similar to what TypeScript, Go, and Rust use. It is practical, easy to understand, and sufficient for our language.</p>
<h2 id="the-algorithm-in-pseudocode"><a class="header" href="#the-algorithm-in-pseudocode">The Algorithm in Pseudocode</a></h2>
<p>Before diving into Rust code, here is the algorithm in pseudocode:</p>
<pre><code class="language-text">ALGORITHM: Local Type Inference
INPUT: AST with some types marked as Unknown
OUTPUT: AST with all types filled in, or an error

1. COLLECT SIGNATURES:
   for each function definition in program:
       record (function_name -&gt; function_type) in environment

2. TYPECHECK EACH STATEMENT:
   for each statement in program:
       typecheck_statement(statement, environment)

FUNCTION typecheck_statement(stmt, env):
   case stmt of:
   | Assignment(name, value):
       inferred_type = typecheck_expr(value, env)
       if explicit_annotation exists:
           check annotation matches inferred_type
       add (name -&gt; inferred_type) to env

   | Function(name, params, body):
       local_env = copy of env
       for each (param_name, param_type) in params:
           add (param_name -&gt; param_type) to local_env
       for each stmt in body:
           typecheck_statement(stmt, local_env)

   | Return(expr):
       typecheck_expr(expr, env)
       check result matches declared return type

FUNCTION typecheck_expr(expr, env) -&gt; Type:
   case expr of:
   | Int(n):       return Int
   | Bool(b):      return Bool
   | Var(name):    return lookup(name, env)
   | Binary(op, left, right):
       left_type = typecheck_expr(left, env)
       right_type = typecheck_expr(right, env)
       return apply_op_rules(op, left_type, right_type)
   | Call(name, args):
       func_type = lookup(name, env)
       for each (arg, expected_type) in zip(args, func_type.params):
           actual_type = typecheck_expr(arg, env)
           check actual_type matches expected_type
       return func_type.return_type
   | If(cond, then, else):
       check typecheck_expr(cond, env) == Bool
       then_type = typecheck_block(then, env)
       else_type = typecheck_block(else, env)
       return unify(then_type, else_type)
</code></pre>
<p>The key insight: types <strong>flow forward</strong> from known sources (literals, parameters) through operations into variables.</p>
<h2 id="the-core-insight"><a class="header" href="#the-core-insight">The Core Insight</a></h2>
<p>Here is the key idea: types <em>flow</em> through expressions. If we know the type of the inputs, we can figure out the type of the output.</p>
<p>Consider <code>x = 1 + 2</code>. How does the compiler know <code>x</code> is an <code>int</code>?</p>
<ol>
<li><code>1</code> is an integer literal → type is <code>Int</code></li>
<li><code>2</code> is an integer literal → type is <code>Int</code></li>
<li><code>+</code> with two <code>Int</code> operands → produces <code>Int</code></li>
<li>We are assigning an <code>Int</code> to <code>x</code> → <code>x</code> must be <code>Int</code></li>
</ol>
<p>The type “flows” from the literals, through the operator, into the variable. No explicit annotation needed.</p>
<h2 id="step-by-step-example"><a class="header" href="#step-by-step-example">Step-by-Step Example</a></h2>
<p>Let us trace through this code in detail:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>x = 42
y = x * 2 + 10
is_big = y &gt; 50
<span class="boring">}</span></code></pre></pre>
<h3 id="step-1-parse-types-are-unknown"><a class="header" href="#step-1-parse-types-are-unknown">Step 1: Parse (types are Unknown)</a></h3>
<p>After parsing, the AST looks like this (simplified):</p>
<pre><code>Assignment { name: "x", value: Int(42), ty: Unknown }
Assignment { name: "y", value: Binary(Var("x") * Int(2) + Int(10)), ty: Unknown }
Assignment { name: "is_big", value: Binary(Var("y") &gt; Int(50)), ty: Unknown }
</code></pre>
<p>Every expression has <code>ty: Unknown</code>. We do not know the types yet.</p>
<h3 id="step-2-type-check-first-assignment"><a class="header" href="#step-2-type-check-first-assignment">Step 2: Type check first assignment</a></h3>
<p>For <code>x = 42</code>:</p>
<ol>
<li>
<p>Check the value <code>42</code>:</p>
<ul>
<li>It is an <code>Int</code> literal</li>
<li>Set its type: <code>Int(42).ty = Int</code></li>
</ul>
</li>
<li>
<p>Infer the variable type:</p>
<ul>
<li>No explicit annotation, so we use the value’s type</li>
<li><code>x</code> has type <code>Int</code></li>
<li>Add to environment: <code>{ x: Int }</code></li>
</ul>
</li>
</ol>
<h3 id="step-3-type-check-second-assignment"><a class="header" href="#step-3-type-check-second-assignment">Step 3: Type check second assignment</a></h3>
<p>For <code>y = x * 2 + 10</code>:</p>
<ol>
<li>
<p>Check <code>x * 2</code>:</p>
<ul>
<li>Look up <code>x</code> in environment → <code>Int</code></li>
<li><code>2</code> is an <code>Int</code> literal</li>
<li><code>*</code> with <code>Int * Int</code> → produces <code>Int</code></li>
<li>Set type: <code>(x * 2).ty = Int</code></li>
</ul>
</li>
<li>
<p>Check <code>(x * 2) + 10</code>:</p>
<ul>
<li>Left side <code>(x * 2)</code> has type <code>Int</code> (from step above)</li>
<li>Right side <code>10</code> is an <code>Int</code> literal</li>
<li><code>+</code> with <code>Int + Int</code> → produces <code>Int</code></li>
<li>Set type: <code>((x * 2) + 10).ty = Int</code></li>
</ul>
</li>
<li>
<p>Infer the variable type:</p>
<ul>
<li>Value has type <code>Int</code></li>
<li><code>y</code> has type <code>Int</code></li>
<li>Add to environment: <code>{ x: Int, y: Int }</code></li>
</ul>
</li>
</ol>
<h3 id="step-4-type-check-third-assignment"><a class="header" href="#step-4-type-check-third-assignment">Step 4: Type check third assignment</a></h3>
<p>For <code>is_big = y &gt; 50</code>:</p>
<ol>
<li>
<p>Check <code>y &gt; 50</code>:</p>
<ul>
<li>Look up <code>y</code> in environment → <code>Int</code></li>
<li><code>50</code> is an <code>Int</code> literal</li>
<li><code>&gt;</code> with <code>Int &gt; Int</code> → produces <code>Bool</code> (comparisons return boolean)</li>
<li>Set type: <code>(y &gt; 50).ty = Bool</code></li>
</ul>
</li>
<li>
<p>Infer the variable type:</p>
<ul>
<li>Value has type <code>Bool</code></li>
<li><code>is_big</code> has type <code>Bool</code></li>
<li>Add to environment: <code>{ x: Int, y: Int, is_big: Bool }</code></li>
</ul>
</li>
</ol>
<h3 id="final-result"><a class="header" href="#final-result">Final Result</a></h3>
<p>All <code>Unknown</code> types are now resolved:</p>
<pre><code>Assignment { name: "x", value: Int(42), ty: Int }
Assignment { name: "y", value: Binary(...), ty: Int }
Assignment { name: "is_big", value: Binary(...), ty: Bool }
</code></pre>
<p>The compiler inferred all the types without us writing a single type annotation.</p>
<h2 id="typing-rules"><a class="header" href="#typing-rules">Typing Rules</a></h2>
<p>The type checker applies these <strong><a href="https://en.wikipedia.org/wiki/Type_rule">typing rules</a></strong>:</p>
<div class="table-wrapper"><table><thead><tr><th>Expression</th><th>Rule</th><th>Result Type</th></tr></thead><tbody>
<tr><td><code>42</code></td><td>Integer literals are <code>Int</code></td><td><code>Int</code></td></tr>
<tr><td><code>true</code>, <code>false</code></td><td>Boolean literals are <code>Bool</code></td><td><code>Bool</code></td></tr>
<tr><td><code>x</code> (variable)</td><td>Look up in <a href="https://en.wikipedia.org/wiki/Type_system#Type_environments">type environment</a></td><td><code>env[x]</code></td></tr>
<tr><td><code>a + b</code>, <code>a * b</code>, etc.</td><td>Both operands must be <code>Int</code></td><td><code>Int</code></td></tr>
<tr><td><code>a &lt; b</code>, <code>a &gt; b</code>, <code>a == b</code></td><td>Both operands must be <code>Int</code></td><td><code>Bool</code></td></tr>
<tr><td><code>!a</code></td><td>Operand must be <code>Bool</code></td><td><code>Bool</code></td></tr>
<tr><td><code>-a</code></td><td>Operand must be <code>Int</code></td><td><code>Int</code></td></tr>
<tr><td><code>f(args...)</code></td><td>Args must match function parameter types</td><td>Function’s return type</td></tr>
<tr><td><code>if (c) { a } else { b }</code></td><td><code>c</code> must be <code>Bool</code>; <code>a</code> and <code>b</code> must unify</td><td>Unified type of <code>a</code> and <code>b</code></td></tr>
</tbody></table>
</div>
<p>These rules are applied recursively, bottom-up through the expression tree.</p>
<h2 id="type-unification"><a class="header" href="#type-unification">Type Unification</a></h2>
<p><strong><a href="https://en.wikipedia.org/wiki/Unification_(computer_science)">Unification</a></strong> is the process of checking if two types are compatible and finding a common type. This is a key operation in type inference.</p>
<p>Here is the pseudocode:</p>
<pre><code class="language-text">FUNCTION unify(type1, type2) -&gt; Type or Error:
   if type1 == type2:
       return type1                    # Same types match
   if type1 == Unknown:
       return type2                    # Unknown takes the other type
   if type2 == Unknown:
       return type1                    # Unknown takes the other type
   if type1 is Function and type2 is Function:
       unify each parameter type
       unify return types
       return unified function type
   else:
       return Error("Cannot unify type1 with type2")
</code></pre>
<p>Our implementation:</p>
<pre><code class="language-rust ignore">    /// Try to unify this type with another type
    /// Returns the unified type if successful, or an error message
    pub fn unify(&amp;self, other: &amp;Type) -&gt; Result&lt;Type, String&gt; {
        match (self, other) {
            // Same types unify
            (Type::Int, Type::Int) =&gt; Ok(Type::Int),
            (Type::Bool, Type::Bool) =&gt; Ok(Type::Bool),
            (Type::Unit, Type::Unit) =&gt; Ok(Type::Unit),

            // Unknown can unify with anything
            (Type::Unknown, t) | (t, Type::Unknown) =&gt; Ok(t.clone()),

            // Function types must have compatible signatures
            (
                Type::Function {
                    params: p1,
                    ret: r1,
                },
                Type::Function {
                    params: p2,
                    ret: r2,
                },
            ) if p1.len() == p2.len() =&gt; {
                let params: Result&lt;Vec&lt;_&gt;, _&gt; =
                    p1.iter().zip(p2.iter()).map(|(a, b)| a.unify(b)).collect();
                let ret = r1.unify(r2)?;
                Ok(Type::Function {
                    params: params?,
                    ret: Box::new(ret),
                })
            }

            // Type mismatch
            _ =&gt; Err(format!(
                "Type mismatch: expected {:?}, got {:?}",
                self, other
            )),
        }
    }</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/secondlang/src/types.rs">secondlang/src/types.rs</a></p>
<p>Let us understand each case:</p>
<div class="table-wrapper"><table><thead><tr><th>Unify</th><th>Result</th><th>Why</th></tr></thead><tbody>
<tr><td><code>Int.unify(Int)</code></td><td><code>Ok(Int)</code></td><td>Same types match</td></tr>
<tr><td><code>Bool.unify(Bool)</code></td><td><code>Ok(Bool)</code></td><td>Same types match</td></tr>
<tr><td><code>Unknown.unify(Int)</code></td><td><code>Ok(Int)</code></td><td>Unknown takes on the concrete type</td></tr>
<tr><td><code>Int.unify(Unknown)</code></td><td><code>Ok(Int)</code></td><td>Unknown takes on the concrete type</td></tr>
<tr><td><code>Int.unify(Bool)</code></td><td><code>Err</code></td><td>Incompatible types cannot unify</td></tr>
</tbody></table>
</div>
<p>The <code>Unknown</code> case is the heart of type inference. When we unify <code>Unknown</code> with a concrete type, we <em>learn</em> what the unknown type should be.</p>
<h2 id="the-type-environment"><a class="header" href="#the-type-environment">The Type Environment</a></h2>
<p>The <strong>type environment</strong> (also called symbol table or context) maps names to types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type TypeEnv = HashMap&lt;String, Type&gt;;
<span class="boring">}</span></code></pre></pre>
<p>The environment is:</p>
<ul>
<li><strong>Extended</strong> when we declare a variable or enter a function (adding new bindings)</li>
<li><strong>Queried</strong> when we reference a variable (looking up its type)</li>
<li><strong>Scoped</strong> - inner scopes can shadow outer bindings</li>
</ul>
<p>This is the same concept as the runtime environment in <a href="03_secondlang/../02_firstlang/variables.html">Firstlang’s interpreter</a>, but storing types instead of values.</p>
<h2 id="function-type-inference"><a class="header" href="#function-type-inference">Function Type Inference</a></h2>
<p>Functions are trickier because we need to handle:</p>
<ol>
<li>Parameters (types come from annotations)</li>
<li>Local variables (types are inferred)</li>
<li>Return value (must match declared return type)</li>
</ol>
<p>Consider:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>def compute(a: int, b: int) -&gt; int {
    temp = a + b        # What type is temp?
    doubled = temp * 2  # What type is doubled?
    return doubled + 1
}
<span class="boring">}</span></code></pre></pre>
<p>The type checker:</p>
<ol>
<li>
<p><strong>Adds parameters to environment</strong>: <code>{ a: Int, b: Int }</code></p>
</li>
<li>
<p><strong>Checks <code>temp = a + b</code></strong>:</p>
<ul>
<li><code>a</code> is <code>Int</code>, <code>b</code> is <code>Int</code></li>
<li><code>a + b</code> is <code>Int</code></li>
<li><code>temp</code> is <code>Int</code></li>
<li>Environment: <code>{ a: Int, b: Int, temp: Int }</code></li>
</ul>
</li>
<li>
<p><strong>Checks <code>doubled = temp * 2</code></strong>:</p>
<ul>
<li><code>temp</code> is <code>Int</code>, <code>2</code> is <code>Int</code></li>
<li><code>temp * 2</code> is <code>Int</code></li>
<li><code>doubled</code> is <code>Int</code></li>
<li>Environment: <code>{ a: Int, b: Int, temp: Int, doubled: Int }</code></li>
</ul>
</li>
<li>
<p><strong>Checks <code>return doubled + 1</code></strong>:</p>
<ul>
<li><code>doubled</code> is <code>Int</code>, <code>1</code> is <code>Int</code></li>
<li><code>doubled + 1</code> is <code>Int</code></li>
<li>Declared return type is <code>Int</code> ✓ matches</li>
</ul>
</li>
</ol>
<p>All types are inferred from the parameter types flowing through the expressions.</p>
<h2 id="the-two-pass-algorithm"><a class="header" href="#the-two-pass-algorithm">The Two-Pass Algorithm</a></h2>
<p>The type checker uses two passes:</p>
<pre><code class="language-rust ignore">/// Type check and infer types for a program
pub fn typecheck(program: &amp;mut Program) -&gt; Result&lt;(), String&gt; {
    let mut env = TypeEnv::new();

    // First pass: collect function signatures
    for stmt in program.iter() {
        if let Stmt::Function {
            name,
            params,
            return_type,
            ..
        } = stmt
        {
            let param_types: Vec&lt;Type&gt; = params.iter().map(|(_, t)| t.clone()).collect();
            let func_type = Type::Function {
                params: param_types,
                ret: Box::new(return_type.clone()),
            };
            env.insert(name.clone(), func_type);
        }
    }

    // Second pass: type check each statement
    for stmt in program.iter_mut() {
        typecheck_stmt(stmt, &amp;mut env)?;
    }

    Ok(())
}</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/secondlang/src/typeck.rs">secondlang/src/typeck.rs</a></p>
<p><strong>Pass 1: Collect function signatures</strong></p>
<p>We scan all function definitions and record their types <em>before</em> checking any bodies. Why? Because functions can call each other (mutual recursion):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>def isEven(n: int) -&gt; bool {
    if (n == 0) { return true }
    else { return isOdd(n - 1) }
}
def isOdd(n: int) -&gt; bool {
    if (n == 0) { return false }
    else { return isEven(n - 1) }
}
<span class="boring">}</span></code></pre></pre>
<p>When checking <code>isEven</code>, we need to know the type of <code>isOdd</code>. By collecting all signatures first, <a href="https://en.wikipedia.org/wiki/Mutual_recursion">mutual recursion</a> works.</p>
<p><strong>Pass 2: Check each statement</strong></p>
<p>Now we go through each statement, inferring types as we go.</p>
<h2 id="type-checking-expressions"><a class="header" href="#type-checking-expressions">Type Checking Expressions</a></h2>
<p>Here is the complete <code>typecheck_expr</code> function:</p>
<pre><code class="language-rust ignore">fn typecheck_expr(expr: &amp;mut TypedExpr, env: &amp;TypeEnv) -&gt; Result&lt;(), String&gt; {
    match &amp;mut expr.expr {
        Expr::Int(_) =&gt; {
            expr.ty = Type::Int;
        }

        Expr::Bool(_) =&gt; {
            expr.ty = Type::Bool;
        }

        Expr::Var(name) =&gt; {
            if let Some(ty) = env.get(name) {
                expr.ty = ty.clone();
            } else {
                return Err(format!("Undefined variable: {}", name));
            }
        }

        Expr::Unary { op, expr: inner } =&gt; {
            typecheck_expr(inner, env)?;
            match op {
                UnaryOp::Neg =&gt; {
                    if inner.ty != Type::Int {
                        return Err(format!("Cannot negate non-integer type: {}", inner.ty));
                    }
                    expr.ty = Type::Int;
                }
                UnaryOp::Not =&gt; {
                    if inner.ty != Type::Bool {
                        return Err(format!("Cannot negate non-boolean type: {}", inner.ty));
                    }
                    expr.ty = Type::Bool;
                }
            }
        }

        Expr::Binary { op, left, right } =&gt; {
            typecheck_expr(left, env)?;
            typecheck_expr(right, env)?;

            match op {
                BinaryOp::Add | BinaryOp::Sub | BinaryOp::Mul | BinaryOp::Div | BinaryOp::Mod =&gt; {
                    if left.ty != Type::Int || right.ty != Type::Int {
                        return Err(format!(
                            "Arithmetic operation requires int operands, got {} and {}",
                            left.ty, right.ty
                        ));
                    }
                    expr.ty = Type::Int;
                }
                BinaryOp::Lt | BinaryOp::Gt | BinaryOp::Le | BinaryOp::Ge =&gt; {
                    if left.ty != Type::Int || right.ty != Type::Int {
                        return Err(format!(
                            "Comparison requires int operands, got {} and {}",
                            left.ty, right.ty
                        ));
                    }
                    expr.ty = Type::Bool;
                }
                BinaryOp::Eq | BinaryOp::Ne =&gt; {
                    let _ = left.ty.unify(&amp;right.ty)?;
                    expr.ty = Type::Bool;
                }
            }
        }

        Expr::Call { name, args } =&gt; {
            // Look up function type
            let func_type = env
                .get(name)
                .ok_or_else(|| format!("Undefined function: {}", name))?
                .clone();

            if let Type::Function { params, ret } = func_type {
                // Check argument count
                if args.len() != params.len() {
                    return Err(format!(
                        "Function {} expects {} arguments, got {}",
                        name,
                        params.len(),
                        args.len()
                    ));
                }

                // Type check each argument
                for (arg, param_type) in args.iter_mut().zip(params.iter()) {
                    typecheck_expr(arg, env)?;
                    let _ = arg.ty.unify(param_type)?;
                }

                expr.ty = *ret;
            } else {
                return Err(format!("{} is not a function", name));
            }
        }

        Expr::If {
            cond,
            then_branch,
            else_branch,
        } =&gt; {
            typecheck_expr(cond, env)?;
            if cond.ty != Type::Bool {
                return Err(format!("If condition must be bool, got {}", cond.ty));
            }

            // Type check branches
            let mut then_env = env.clone();
            let mut then_type = Type::Unit;
            for stmt in then_branch.iter_mut() {
                then_type = typecheck_stmt(stmt, &amp;mut then_env)?;
            }

            let mut else_env = env.clone();
            let mut else_type = Type::Unit;
            for stmt in else_branch.iter_mut() {
                else_type = typecheck_stmt(stmt, &amp;mut else_env)?;
            }

            // Branches must have same type
            expr.ty = then_type.unify(&amp;else_type)?;
        }

        Expr::While { cond, body } =&gt; {
            typecheck_expr(cond, env)?;
            if cond.ty != Type::Bool {
                return Err(format!("While condition must be bool, got {}", cond.ty));
            }

            let mut body_env = env.clone();
            for stmt in body.iter_mut() {
                typecheck_stmt(stmt, &amp;mut body_env)?;
            }

            expr.ty = Type::Unit;
        }

        Expr::Block(stmts) =&gt; {
            let mut block_env = env.clone();
            let mut last_type = Type::Unit;
            for stmt in stmts.iter_mut() {
                last_type = typecheck_stmt(stmt, &amp;mut block_env)?;
            }
            expr.ty = last_type;
        }
    }

    Ok(())
}</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/secondlang/src/typeck.rs">secondlang/src/typeck.rs</a></p>
<p>The pattern is always the same:</p>
<ol>
<li>Recursively type check sub-expressions</li>
<li>Apply the typing rule for this expression kind</li>
<li>Set the type on this expression</li>
</ol>
<h2 id="when-inference-fails"><a class="header" href="#when-inference-fails">When Inference Fails</a></h2>
<p>Type inference is not magic. It fails when there is not enough information:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">This would fail - what type is x?
</span>x = some_function_that_could_return_anything()
<span class="boring">}</span></code></pre></pre>
<p>Or when types conflict:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>x = 42
x = true  # Error: x is Int, cannot assign Bool
<span class="boring">}</span></code></pre></pre>
<p>We report errors with helpful messages:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = typecheck("1 + true");
// Error: "Arithmetic operation requires int operands, got int and bool"

let result = typecheck("add(1, true)");
// Error: "Type mismatch: expected int, got bool"
<span class="boring">}</span></code></pre></pre>
<h2 id="limitations-of-local-inference"><a class="header" href="#limitations-of-local-inference">Limitations of Local Inference</a></h2>
<p>Our inference cannot handle some things that Hindley-Milner can:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">Hindley-Milner could infer: identity : forall a. a -&gt; a
</span>def identity(x) {
    return x
}

<span class="boring">We require annotations:
</span>def identity(x: int) -&gt; int {
    return x
}
<span class="boring">}</span></code></pre></pre>
<p>For a simple language like Secondlang, this is fine. The annotation burden is low (just function boundaries), and the implementation is much simpler.</p>
<h2 id="comparison-with-other-systems"><a class="header" href="#comparison-with-other-systems">Comparison with Other Systems</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Secondlang</th><th>TypeScript</th><th>Haskell</th></tr></thead><tbody>
<tr><td>Variable inference</td><td>✓</td><td>✓</td><td>✓</td></tr>
<tr><td>Function param inference</td><td>✗</td><td>Partial</td><td>✓</td></tr>
<tr><td>Polymorphism</td><td>✗</td><td>✓ (generics)</td><td>✓ (parametric)</td></tr>
<tr><td>Bidirectional</td><td>✗</td><td>✓</td><td>Partial</td></tr>
</tbody></table>
</div>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Type inference works by:</p>
<ol>
<li><strong>Starting with known types</strong>: literals (<code>42</code> → Int, <code>true</code> → Bool) and annotated parameters</li>
<li><strong>Flowing types through expressions</strong>: operators, function calls, assignments</li>
<li><strong>Recording types in the environment</strong>: so variables can be looked up later</li>
<li><strong>Unifying types</strong>: checking compatibility and resolving <code>Unknown</code></li>
<li><strong>Reporting errors</strong>: when types do not match</li>
</ol>
<p>The beauty is that most of the time, you only need to annotate function parameters and return types. Everything else is inferred automatically.</p>
<h2 id="further-reading-1"><a class="header" href="#further-reading-1">Further Reading</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Type_inference">Type Inference on Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">Hindley-Milner Type System</a></li>
<li><a href="https://en.wikipedia.org/wiki/Unification_(computer_science)">Unification in Computer Science</a></li>
<li><a href="https://www.cis.upenn.edu/~bcpierce/tapl/">Types and Programming Languages</a> by Benjamin Pierce - the definitive textbook</li>
</ul>
<h2 id="try-it-yourself"><a class="header" href="#try-it-yourself">Try It Yourself</a></h2>
<p>Run the inference example:</p>
<pre><code class="language-bash">rustup run nightly cargo run -- examples/inference.sl
</code></pre>
<p>This demonstrates all the inference concepts in action.</p>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<pre><code class="language-bash">cargo test typeck
</code></pre>
<p>In the next chapter, we look at <a href="03_secondlang/./optimizations.html">optimizations</a> we can do on the typed AST before generating code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ast-optimizations"><a class="header" href="#ast-optimizations">AST Optimizations</a></h1>
<p>Before we generate <a href="03_secondlang/./codegen.html">LLVM code</a>, we can make the AST <em>better</em>. By “better”, we mean simpler expressions that do the same thing. For example, <code>1 + 2 * 3</code> can become just <code>7</code>. This is called <strong><a href="https://en.wikipedia.org/wiki/Optimizing_compiler">optimization</a></strong>.</p>
<p>In this chapter, we introduce the <strong><a href="https://en.wikipedia.org/wiki/Visitor_pattern">visitor pattern</a></strong>, a classic technique for walking through and transforming ASTs.</p>
<h2 id="the-visitor-pattern"><a class="header" href="#the-visitor-pattern">The Visitor Pattern</a></h2>
<p>Imagine we want to add a new operation on our AST, like “pretty print” or “count variables” or “simplify expressions”. Without a good design, we would need to modify every AST node type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bad: scattered across many files
impl Expr {
    fn pretty_print(&amp;self) { ... }
    fn count_variables(&amp;self) { ... }
    fn simplify(&amp;self) { ... }
}
<span class="boring">}</span></code></pre></pre>
<p>Every time we add a new operation, we touch every node. That gets messy.</p>
<p>The visitor pattern flips this around. Instead of adding methods to nodes, we create separate <em>visitor</em> objects:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PrettyPrinter;
impl ExprVisitor for PrettyPrinter { ... }

struct ConstantFolder;
impl ExprVisitor for ConstantFolder { ... }
<span class="boring">}</span></code></pre></pre>
<p>Each visitor is self-contained. Adding a new operation means adding a new visitor, not modifying existing code. This follows the <a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">open/closed principle</a>: open for extension, closed for modification.</p>
<h2 id="the-exprvisitor-trait"><a class="header" href="#the-exprvisitor-trait">The ExprVisitor Trait</a></h2>
<p>Our visitor trait provides a hook for each expression type:</p>
<pre><code class="language-rust ignore">/// Visitor trait for traversing typed expressions
///
/// Each visit method returns the transformed expression.
/// Default implementations traverse children recursively.
pub trait ExprVisitor {
    /// Visit any expression - dispatches to specific visit methods
    fn visit_expr(&amp;mut self, expr: &amp;TypedExpr) -&gt; TypedExpr {
        let new_expr = match &amp;expr.expr {
            Expr::Int(n) =&gt; self.visit_int(*n),
            Expr::Bool(b) =&gt; self.visit_bool(*b),
            Expr::Var(name) =&gt; self.visit_var(name),
            Expr::Unary { op, expr: inner } =&gt; self.visit_unary(*op, inner),
            Expr::Binary { op, left, right } =&gt; self.visit_binary(*op, left, right),
            Expr::Call { name, args } =&gt; self.visit_call(name, args),
            Expr::If {
                cond,
                then_branch,
                else_branch,
            } =&gt; self.visit_if(cond, then_branch, else_branch),
            Expr::While { cond, body } =&gt; self.visit_while(cond, body),
            Expr::Block(stmts) =&gt; self.visit_block(stmts),
        };
        TypedExpr {
            expr: new_expr,
            ty: expr.ty.clone(),
        }
    }

    fn visit_int(&amp;mut self, n: i64) -&gt; Expr {
        Expr::Int(n)
    }

    fn visit_bool(&amp;mut self, b: bool) -&gt; Expr {
        Expr::Bool(b)
    }

    fn visit_var(&amp;mut self, name: &amp;str) -&gt; Expr {
        Expr::Var(name.to_string())
    }

    fn visit_unary(&amp;mut self, op: UnaryOp, expr: &amp;TypedExpr) -&gt; Expr {
        let visited = self.visit_expr(expr);
        Expr::Unary {
            op,
            expr: Box::new(visited),
        }
    }

    fn visit_binary(&amp;mut self, op: BinaryOp, left: &amp;TypedExpr, right: &amp;TypedExpr) -&gt; Expr {
        let l = self.visit_expr(left);
        let r = self.visit_expr(right);
        Expr::Binary {
            op,
            left: Box::new(l),
            right: Box::new(r),
        }
    }

    fn visit_call(&amp;mut self, name: &amp;str, args: &amp;[TypedExpr]) -&gt; Expr {
        let visited_args: Vec&lt;TypedExpr&gt; = args.iter().map(|a| self.visit_expr(a)).collect();
        Expr::Call {
            name: name.to_string(),
            args: visited_args,
        }
    }

    fn visit_if(&amp;mut self, cond: &amp;TypedExpr, then_branch: &amp;[Stmt], else_branch: &amp;[Stmt]) -&gt; Expr {
        let visited_cond = self.visit_expr(cond);
        let visited_then: Vec&lt;Stmt&gt; = then_branch.iter().map(|s| self.visit_stmt(s)).collect();
        let visited_else: Vec&lt;Stmt&gt; = else_branch.iter().map(|s| self.visit_stmt(s)).collect();
        Expr::If {
            cond: Box::new(visited_cond),
            then_branch: visited_then,
            else_branch: visited_else,
        }
    }

    fn visit_while(&amp;mut self, cond: &amp;TypedExpr, body: &amp;[Stmt]) -&gt; Expr {
        let visited_cond = self.visit_expr(cond);
        let visited_body: Vec&lt;Stmt&gt; = body.iter().map(|s| self.visit_stmt(s)).collect();
        Expr::While {
            cond: Box::new(visited_cond),
            body: visited_body,
        }
    }

    fn visit_block(&amp;mut self, stmts: &amp;[Stmt]) -&gt; Expr {
        let visited: Vec&lt;Stmt&gt; = stmts.iter().map(|s| self.visit_stmt(s)).collect();
        Expr::Block(visited)
    }

    /// Visit a statement
    fn visit_stmt(&amp;mut self, stmt: &amp;Stmt) -&gt; Stmt {
        match stmt {
            Stmt::Function {
                name,
                params,
                return_type,
                body,
            } =&gt; {
                let visited_body: Vec&lt;Stmt&gt; = body.iter().map(|s| self.visit_stmt(s)).collect();
                Stmt::Function {
                    name: name.clone(),
                    params: params.clone(),
                    return_type: return_type.clone(),
                    body: visited_body,
                }
            }
            Stmt::Return(expr) =&gt; Stmt::Return(self.visit_expr(expr)),
            Stmt::Assignment {
                name,
                type_ann,
                value,
            } =&gt; Stmt::Assignment {
                name: name.clone(),
                type_ann: type_ann.clone(),
                value: self.visit_expr(value),
            },
            Stmt::Expr(expr) =&gt; Stmt::Expr(self.visit_expr(expr)),
        }
    }
}</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/secondlang/src/visitor.rs">secondlang/src/visitor.rs</a></p>
<p>Let us understand how this works:</p>
<ol>
<li>
<p><code>visit_expr</code> is the entry point. It looks at the expression type and calls the appropriate visitor method.</p>
</li>
<li>
<p>Each <code>visit_*</code> method has a <em>default implementation</em> that just recurses into children. For example, <code>visit_binary</code> visits left and right, then rebuilds the binary expression.</p>
</li>
<li>
<p>To customize behavior, we override the methods we care about. For constant folding, we override <code>visit_binary</code> to check if both operands are constants.</p>
</li>
</ol>
<p>This is sometimes called a <strong>tree walk</strong> or <strong><a href="https://en.wikipedia.org/wiki/Tree_traversal">tree traversal</a></strong>.</p>
<h2 id="optimization-1-constant-folding"><a class="header" href="#optimization-1-constant-folding">Optimization 1: Constant Folding</a></h2>
<p><strong><a href="https://en.wikipedia.org/wiki/Constant_folding">Constant folding</a></strong> evaluates expressions where all values are known at compile time:</p>
<p>$$
\begin{aligned}
1 + 2 \times 3 &amp;\Rightarrow 7 \\
5 &lt; 10 &amp;\Rightarrow \text{true} \\
-(-42) &amp;\Rightarrow 42
\end{aligned}
$$</p>
<p>Why wait until runtime to compute <code>1 + 2</code> when we can do it now?</p>
<p>Here is the pseudocode:</p>
<pre><code class="language-text">FUNCTION constant_fold(expr):
   case expr of:
   | Binary(op, left, right):
       folded_left = constant_fold(left)
       folded_right = constant_fold(right)

       if both folded_left and folded_right are constants:
           compute the result at compile time
           return the constant result
       else:
           return Binary(op, folded_left, folded_right)

   | Unary(op, inner):
       folded = constant_fold(inner)
       if folded is a constant:
           compute result
           return constant
       else:
           return Unary(op, folded)

   | other:
       return expr  # cannot fold
</code></pre>
<p>And the implementation:</p>
<pre><code class="language-rust ignore">/// Folds constant expressions: `1 + 2` becomes `3`
///
/// This is a simple optimization that evaluates expressions
/// where all operands are known at compile time.
pub struct ConstantFolder;

impl ConstantFolder {
    pub fn new() -&gt; Self {
        ConstantFolder
    }

    pub fn fold_program(stmts: &amp;[Stmt]) -&gt; Vec&lt;Stmt&gt; {
        let mut folder = ConstantFolder::new();
        stmts.iter().map(|s| folder.visit_stmt(s)).collect()
    }
}

impl Default for ConstantFolder {
    fn default() -&gt; Self {
        Self::new()
    }
}

impl ExprVisitor for ConstantFolder {
    fn visit_binary(&amp;mut self, op: BinaryOp, left: &amp;TypedExpr, right: &amp;TypedExpr) -&gt; Expr {
        // First, recursively fold children
        let l = self.visit_expr(left);
        let r = self.visit_expr(right);

        // Try to fold if both are constants
        if let (Expr::Int(lv), Expr::Int(rv)) = (&amp;l.expr, &amp;r.expr) {
            let result = match op {
                BinaryOp::Add =&gt; Some(lv + rv),
                BinaryOp::Sub =&gt; Some(lv - rv),
                BinaryOp::Mul =&gt; Some(lv * rv),
                BinaryOp::Div if *rv != 0 =&gt; Some(lv / rv),
                BinaryOp::Mod if *rv != 0 =&gt; Some(lv % rv),
                _ =&gt; None,
            };
            if let Some(val) = result {
                return Expr::Int(val);
            }
        }

        // Try boolean constant folding for comparisons
        if let (Expr::Int(lv), Expr::Int(rv)) = (&amp;l.expr, &amp;r.expr) {
            let result = match op {
                BinaryOp::Lt =&gt; Some(*lv &lt; *rv),
                BinaryOp::Gt =&gt; Some(*lv &gt; *rv),
                BinaryOp::Le =&gt; Some(*lv &lt;= *rv),
                BinaryOp::Ge =&gt; Some(*lv &gt;= *rv),
                BinaryOp::Eq =&gt; Some(*lv == *rv),
                BinaryOp::Ne =&gt; Some(*lv != *rv),
                _ =&gt; None,
            };
            if let Some(val) = result {
                return Expr::Bool(val);
            }
        }

        // Can't fold, return as-is
        Expr::Binary {
            op,
            left: Box::new(l),
            right: Box::new(r),
        }
    }

    fn visit_unary(&amp;mut self, op: UnaryOp, expr: &amp;TypedExpr) -&gt; Expr {
        let e = self.visit_expr(expr);

        match (&amp;op, &amp;e.expr) {
            (UnaryOp::Neg, Expr::Int(n)) =&gt; Expr::Int(-n),
            (UnaryOp::Not, Expr::Bool(b)) =&gt; Expr::Bool(!b),
            _ =&gt; Expr::Unary {
                op,
                expr: Box::new(e),
            },
        }
    }
}</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/secondlang/src/visitor.rs">secondlang/src/visitor.rs</a></p>
<p>Let us trace through <code>1 + 2 * 3</code>:</p>
<ol>
<li>Visit outer <code>+</code> expression</li>
<li>Recursively visit left (<code>1</code>) → returns <code>Int(1)</code></li>
<li>Recursively visit right (<code>2 * 3</code>) → visits <code>*</code>, finds <code>Int(2)</code> and <code>Int(3)</code>, returns <code>Int(6)</code></li>
<li>Back at <code>+</code>: left is <code>Int(1)</code>, right is <code>Int(6)</code> → return <code>Int(7)</code></li>
</ol>
<p>The whole expression becomes just <code>7</code>.</p>
<h2 id="optimization-2-algebraic-simplification"><a class="header" href="#optimization-2-algebraic-simplification">Optimization 2: Algebraic Simplification</a></h2>
<p><strong><a href="https://en.wikipedia.org/wiki/Algebraic_simplification">Algebraic simplification</a></strong> (also called <strong>strength reduction</strong>) applies mathematical identities:</p>
<div class="table-wrapper"><table><thead><tr><th>Expression</th><th>Simplified</th><th>Identity Applied</th></tr></thead><tbody>
<tr><td><code>x + 0</code></td><td><code>x</code></td><td>Additive identity</td></tr>
<tr><td><code>x - 0</code></td><td><code>x</code></td><td>Additive identity</td></tr>
<tr><td><code>x * 0</code></td><td><code>0</code></td><td>Zero property</td></tr>
<tr><td><code>x * 1</code></td><td><code>x</code></td><td>Multiplicative identity</td></tr>
<tr><td><code>x / 1</code></td><td><code>x</code></td><td>Multiplicative identity</td></tr>
<tr><td><code>0 + x</code></td><td><code>x</code></td><td>Commutativity + identity</td></tr>
<tr><td><code>1 * x</code></td><td><code>x</code></td><td>Commutativity + identity</td></tr>
</tbody></table>
</div>
<p>These transformations are always valid and can save runtime computation.</p>
<p>Pseudocode:</p>
<pre><code class="language-text">FUNCTION simplify(expr):
   case expr of:
   | Binary(Add, x, Int(0)): return simplify(x)
   | Binary(Add, Int(0), x): return simplify(x)
   | Binary(Mul, x, Int(1)): return simplify(x)
   | Binary(Mul, Int(1), x): return simplify(x)
   | Binary(Mul, _, Int(0)): return Int(0)
   | Binary(Mul, Int(0), _): return Int(0)
   | ... # other cases
   | Binary(op, left, right):
       return Binary(op, simplify(left), simplify(right))
   | other:
       return expr
</code></pre>
<p>Implementation:</p>
<pre><code class="language-rust ignore">/// Applies algebraic simplifications:
/// - `x + 0` → `x`
/// - `x - 0` → `x`
/// - `x * 0` → `0`
/// - `x * 1` → `x`
/// - `x / 1` → `x`
/// - `0 + x` → `x`
/// - `1 * x` → `x`
/// - `0 * x` → `0`
pub struct AlgebraicSimplifier;

impl AlgebraicSimplifier {
    pub fn new() -&gt; Self {
        AlgebraicSimplifier
    }

    pub fn simplify_program(stmts: &amp;[Stmt]) -&gt; Vec&lt;Stmt&gt; {
        let mut simplifier = AlgebraicSimplifier::new();
        stmts.iter().map(|s| simplifier.visit_stmt(s)).collect()
    }
}

impl Default for AlgebraicSimplifier {
    fn default() -&gt; Self {
        Self::new()
    }
}

impl ExprVisitor for AlgebraicSimplifier {
    fn visit_binary(&amp;mut self, op: BinaryOp, left: &amp;TypedExpr, right: &amp;TypedExpr) -&gt; Expr {
        // First, recursively simplify children
        let l = self.visit_expr(left);
        let r = self.visit_expr(right);

        // Apply algebraic identities
        match (&amp;op, &amp;l.expr, &amp;r.expr) {
            // x + 0 = x
            (BinaryOp::Add, _, Expr::Int(0)) =&gt; return l.expr,
            // 0 + x = x
            (BinaryOp::Add, Expr::Int(0), _) =&gt; return r.expr,
            // x - 0 = x
            (BinaryOp::Sub, _, Expr::Int(0)) =&gt; return l.expr,
            // x * 0 = 0
            (BinaryOp::Mul, _, Expr::Int(0)) =&gt; return Expr::Int(0),
            // 0 * x = 0
            (BinaryOp::Mul, Expr::Int(0), _) =&gt; return Expr::Int(0),
            // x * 1 = x
            (BinaryOp::Mul, _, Expr::Int(1)) =&gt; return l.expr,
            // 1 * x = x
            (BinaryOp::Mul, Expr::Int(1), _) =&gt; return r.expr,
            // x / 1 = x
            (BinaryOp::Div, _, Expr::Int(1)) =&gt; return l.expr,
            _ =&gt; {}
        }

        Expr::Binary {
            op,
            left: Box::new(l),
            right: Box::new(r),
        }
    }
}</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/secondlang/src/visitor.rs">secondlang/src/visitor.rs</a></p>
<h2 id="chaining-optimizations"><a class="header" href="#chaining-optimizations">Chaining Optimizations</a></h2>
<p>Multiple optimization passes can be chained. This is called a <strong><a href="https://en.wikipedia.org/wiki/Multi-pass_compiler">pass pipeline</a></strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn optimize_program(program: &amp;Program) -&gt; Program {
    // First: fold constants
    let program = ConstantFolder::fold_program(&amp;program);
    // Then: simplify algebra
    AlgebraicSimplifier::simplify_program(&amp;program)
}
<span class="boring">}</span></code></pre></pre>
<p>Consider <code>x * (1 + 0)</code>:</p>
<ol>
<li>After constant folding: <code>x * 1</code> (because <code>1 + 0 = 1</code>)</li>
<li>After algebraic simplification: <code>x</code> (because <code>x * 1 = x</code>)</li>
</ol>
<p>Two passes, significant simplification. The order matters - constant folding first creates opportunities for algebraic simplification.</p>
<h2 id="why-bother"><a class="header" href="#why-bother">Why Bother?</a></h2>
<p>You might wonder: “LLVM will optimize this anyway. Why do it ourselves?”</p>
<p>Good question. LLVM <em>will</em> do these optimizations. But:</p>
<ol>
<li>
<p><strong>Learning</strong>: Implementing optimizations helps you understand how compilers work. These are the same techniques used in production compilers.</p>
</li>
<li>
<p><strong>Simplicity</strong>: Simpler AST means simpler code generation. Less can go wrong.</p>
</li>
<li>
<p><strong>Debug output</strong>: When you print the AST for debugging, optimized code is easier to read.</p>
</li>
<li>
<p><strong>Specialized optimizations</strong>: You might know things about your language that LLVM does not. Custom optimizations can exploit that knowledge.</p>
</li>
<li>
<p><strong>Compile time</strong>: Simpler AST means less work for LLVM, which means faster compilation.</p>
</li>
</ol>
<h2 id="other-common-optimizations"><a class="header" href="#other-common-optimizations">Other Common Optimizations</a></h2>
<p>Production compilers do many more optimizations:</p>
<div class="table-wrapper"><table><thead><tr><th>Optimization</th><th>What it does</th></tr></thead><tbody>
<tr><td><a href="https://en.wikipedia.org/wiki/Dead_code_elimination">Dead code elimination</a></td><td>Remove unreachable code</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Common_subexpression_elimination">Common subexpression elimination</a></td><td>Compute <code>x * y</code> once if used twice</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Loop_unrolling">Loop unrolling</a></td><td>Replace loops with repeated code</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Inline_expansion">Inlining</a></td><td>Replace function calls with function bodies</td></tr>
<tr><td><a href="https://en.wikipedia.org/wiki/Tail_call">Tail call optimization</a></td><td>Turn tail recursion into loops</td></tr>
</tbody></table>
</div>
<p>We leave these as exercises. The visitor pattern makes adding new optimizations straightforward.</p>
<h2 id="using-the-optimizations"><a class="header" href="#using-the-optimizations">Using the Optimizations</a></h2>
<p>Enable optimizations with the <code>-O</code> flag:</p>
<pre><code class="language-bash"># Without optimization
secondlang --ir examples/fibonacci.sl

# With optimization
secondlang --ir -O examples/fibonacci.sl
</code></pre>
<h2 id="testing-1"><a class="header" href="#testing-1">Testing</a></h2>
<pre><code class="language-bash">cargo test visitor
</code></pre>
<p>In the next chapter, we look at what <a href="03_secondlang/./ir.html">LLVM IR</a> looks like before we start generating it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-ast-to-ir"><a class="header" href="#from-ast-to-ir">From AST to IR</a></h1>
<p>Now we have a typed, <a href="03_secondlang/./optimizations.html">optimized</a> AST. The next step is to convert it to <strong><a href="https://en.wikipedia.org/wiki/LLVM#Intermediate_representation">LLVM IR</a></strong> (Intermediate Representation). But before we write the <a href="03_secondlang/./codegen.html">code generator</a>, let us understand what LLVM IR looks like.</p>
<h2 id="what-is-llvm-ir"><a class="header" href="#what-is-llvm-ir">What is LLVM IR?</a></h2>
<p><a href="https://llvm.org/">LLVM</a> is a compiler infrastructure project that provides a set of reusable compiler and toolchain technologies. The key idea: you compile your language to LLVM IR, and LLVM handles everything else - optimization, code generation for different platforms, etc.</p>
<p>As discussed in the <a href="03_secondlang/../crash_course.html#intermediate-representation-ir">Crash Course</a>, an <a href="https://en.wikipedia.org/wiki/Intermediate_representation">IR</a> is any representation between source and assembly:</p>
<pre><code>Secondlang Source Code
         |
    [Your Compiler]
         |
      LLVM IR
         |
       [LLVM]
         |
   Machine Code (x86, ARM, etc.)
</code></pre>
<p>Think of IR as a <em>universal assembly language</em>. It is low-level (close to the machine) but not tied to any specific CPU. LLVM takes IR and produces optimized machine code for whatever platform you are on.</p>
<p>Many languages use LLVM: Rust, Swift, Julia, Kotlin/Native, and more. By using LLVM, we get world-class optimizations for free.</p>
<h2 id="a-simple-example"><a class="header" href="#a-simple-example">A Simple Example</a></h2>
<p>Let us see what LLVM IR looks like. Here is a Secondlang function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>def answer() -&gt; int {
    return 42
}
<span class="boring">}</span></code></pre></pre>
<p>And here is the LLVM IR it compiles to:</p>
<pre><code class="language-llvm">define i64 @answer() {
entry:
  ret i64 42
}
</code></pre>
<p>Let us break this down piece by piece:</p>
<ul>
<li><code>define i64 @answer()</code> - We are defining a function called <code>answer</code> that returns a 64-bit integer (<code>i64</code>) and takes no parameters</li>
<li><code>entry:</code> - This is a <strong>label</strong> marking the start of a <strong><a href="https://en.wikipedia.org/wiki/Basic_block">basic block</a></strong> (a sequence of instructions with no branches in the middle)</li>
<li><code>ret i64 42</code> - Return the 64-bit integer value 42</li>
</ul>
<p>That is it. Our function just returns 42.</p>
<h2 id="ir-for-arithmetic"><a class="header" href="#ir-for-arithmetic">IR for Arithmetic</a></h2>
<p>Here is a function that adds two numbers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>def add(a: int, b: int) -&gt; int {
    return a + b
}
<span class="boring">}</span></code></pre></pre>
<p>LLVM IR:</p>
<pre><code class="language-llvm">define i64 @add(i64 %a, i64 %b) {
entry:
  %a.addr = alloca i64           ; allocate stack space for a
  store i64 %a, ptr %a.addr      ; store parameter a
  %b.addr = alloca i64           ; allocate stack space for b
  store i64 %b, ptr %b.addr      ; store parameter b
  %0 = load i64, ptr %a.addr     ; load a
  %1 = load i64, ptr %b.addr     ; load b
  %add = add i64 %0, %1          ; add them
  ret i64 %add                   ; return result
}
</code></pre>
<p>This looks more complex. Let us understand it:</p>
<ol>
<li><strong>Parameters</strong> (<code>%a</code>, <code>%b</code>) come in as values</li>
<li><strong>Allocate stack space</strong> with <code>alloca</code> - we create local variables <code>%a.addr</code> and <code>%b.addr</code></li>
<li><strong>Store parameters</strong> into the stack slots with <code>store</code></li>
<li><strong>Load values</strong> back from stack with <code>load</code></li>
<li><strong>Add</strong> the loaded values with <code>add i64</code></li>
<li><strong>Return</strong> the result</li>
</ol>
<h3 id="why-all-the-loading-and-storing"><a class="header" href="#why-all-the-loading-and-storing">Why All the Loading and Storing?</a></h3>
<p>This pattern looks wasteful. Why not just use <code>%a</code> and <code>%b</code> directly?</p>
<p>The answer is <strong>mutability</strong>. In LLVM IR, values like <code>%a</code> are immutable - you cannot change them. But in most languages, variables <em>can</em> change:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>x = 5
x = x + 1    // x is now 6
<span class="boring">}</span></code></pre></pre>
<p>By storing variables in stack slots (<code>alloca</code>), we can modify them:</p>
<pre><code class="language-llvm">%x.addr = alloca i64
store i64 5, ptr %x.addr           ; x = 5
%tmp = load i64, ptr %x.addr       ; load x
%tmp2 = add i64 %tmp, 1            ; x + 1
store i64 %tmp2, ptr %x.addr       ; x = x + 1
</code></pre>
<p>This is called the <strong>alloca/load/store pattern</strong>. It is simple to generate and LLVM optimizes it away (the <a href="https://llvm.org/docs/Passes.html#mem2reg-promote-memory-to-register">mem2reg pass</a> promotes stack slots to registers) when possible.</p>
<h2 id="ir-for-conditionals"><a class="header" href="#ir-for-conditionals">IR for Conditionals</a></h2>
<p>Conditionals require <strong>branching</strong> - jumping to different code based on a condition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>def max(a: int, b: int) -&gt; int {
    if (a &gt; b) {
        return a
    } else {
        return b
    }
}
<span class="boring">}</span></code></pre></pre>
<p>LLVM IR:</p>
<pre><code class="language-llvm">define i64 @max(i64 %a, i64 %b) {
entry:
  %cmp = icmp sgt i64 %a, %b     ; compare: is a &gt; b? (signed greater than)
  br i1 %cmp, label %then, label %else  ; branch based on result

then:
  ret i64 %a                     ; return a

else:
  ret i64 %b                     ; return b
}
</code></pre>
<p>Key instructions:</p>
<ul>
<li><code>icmp sgt</code> - Integer compare, signed greater than. Returns an <code>i1</code> (1-bit integer, a boolean)</li>
<li><code>br i1 %cmp, label %then, label %else</code> - <a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">Branch</a>: if <code>%cmp</code> is true, go to <code>then</code>, else go to <code>else</code></li>
</ul>
<p>Notice we have multiple <strong>basic blocks</strong> now: <code>entry</code>, <code>then</code>, and <code>else</code>. Each block ends with a <strong>terminator</strong> (like <code>ret</code> or <code>br</code>) that says where to go next.</p>
<h2 id="ssa-form"><a class="header" href="#ssa-form">SSA Form</a></h2>
<p>LLVM IR uses <strong><a href="https://en.wikipedia.org/wiki/Static_single-assignment_form">Static Single Assignment (SSA)</a></strong> form. This means every variable is assigned exactly once.</p>
<p>Consider this code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>x = 1
x = 2
x = 3
<span class="boring">}</span></code></pre></pre>
<p>In SSA form, we cannot reuse <code>x</code>. Instead, we create new names:</p>
<pre><code class="language-llvm">%x.1 = ...   ; first assignment
%x.2 = ...   ; second assignment
%x.3 = ...   ; third assignment
</code></pre>
<p>Each name appears on the left side of exactly one assignment.</p>
<p>Why SSA? It makes optimization easier. The compiler always knows exactly where each value was defined. This enables powerful optimizations like <a href="https://en.wikipedia.org/wiki/Dead_code_elimination">dead code elimination</a>, <a href="https://en.wikipedia.org/wiki/Constant_folding#Constant_propagation">constant propagation</a>, and <a href="https://en.wikipedia.org/wiki/Common_subexpression_elimination">common subexpression elimination</a>.</p>
<h2 id="phi-nodes-merging-values-from-different-paths"><a class="header" href="#phi-nodes-merging-values-from-different-paths">Phi Nodes: Merging Values from Different Paths</a></h2>
<p>SSA creates a problem with conditionals. Consider:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>def pick(cond: bool, a: int, b: int) -&gt; int {
    if (cond) {
        x = a
    } else {
        x = b
    }
    return x
}
<span class="boring">}</span></code></pre></pre>
<p>After the if/else, what is <code>x</code>? It depends on which branch we took. In SSA, we need different names:</p>
<pre><code class="language-llvm">then:
  %x.then = ...
  br label %merge

else:
  %x.else = ...
  br label %merge

merge:
  ; what goes here? We need x, but is it %x.then or %x.else?
</code></pre>
<p>The answer is a <strong><a href="https://en.wikipedia.org/wiki/Static_single-assignment_form#Converting_to_SSA">phi node</a></strong> (φ). A phi node selects a value based on which block we came from:</p>
<pre><code class="language-llvm">merge:
  %x = phi i64 [ %x.then, %then ], [ %x.else, %else ]
  ret i64 %x
</code></pre>
<p>This reads as: “If we came from <code>%then</code>, use <code>%x.then</code>. If we came from <code>%else</code>, use <code>%x.else</code>.”</p>
<p>Phi nodes are the only way to merge values from different <a href="https://en.wikipedia.org/wiki/Control_flow">control flow</a> paths in SSA.</p>
<h2 id="ir-for-recursion"><a class="header" href="#ir-for-recursion">IR for Recursion</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Recursion_(computer_science)">Recursive</a> functions use the <code>call</code> instruction:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>def fib(n: int) -&gt; int {
    if (n &lt; 2) {
        return n
    } else {
        return fib(n - 1) + fib(n - 2)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>LLVM IR (simplified):</p>
<pre><code class="language-llvm">define i64 @fib(i64 %n) {
entry:
  %cmp = icmp slt i64 %n, 2      ; is n &lt; 2?
  br i1 %cmp, label %then, label %else

then:
  ret i64 %n                     ; return n

else:
  %n1 = sub i64 %n, 1            ; n - 1
  %fib1 = call i64 @fib(i64 %n1) ; fib(n - 1)
  %n2 = sub i64 %n, 2            ; n - 2
  %fib2 = call i64 @fib(i64 %n2) ; fib(n - 2)
  %result = add i64 %fib1, %fib2 ; fib(n-1) + fib(n-2)
  ret i64 %result
}
</code></pre>
<p>The <code>call</code> instruction calls a function and returns its result. Recursion is just calling the same function from within itself.</p>
<h2 id="type-mapping"><a class="header" href="#type-mapping">Type Mapping</a></h2>
<p>Our types map to LLVM types:</p>
<div class="table-wrapper"><table><thead><tr><th>Secondlang</th><th>LLVM IR</th><th>Notes</th></tr></thead><tbody>
<tr><td><code>int</code></td><td><code>i64</code></td><td>64-bit signed integer</td></tr>
<tr><td><code>bool</code></td><td><code>i1</code> or <code>i64</code></td><td>1-bit for branches, 64-bit for storage</td></tr>
</tbody></table>
</div>
<p>We use <code>i64</code> for booleans in most places (simpler), and truncate to <code>i1</code> only when needed for branches.</p>
<p>LLVM supports many integer sizes: <code>i1</code>, <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, etc. The number is the bit width.</p>
<h2 id="viewing-generated-ir"><a class="header" href="#viewing-generated-ir">Viewing Generated IR</a></h2>
<p>You can see the IR your programs compile to:</p>
<pre><code class="language-bash">rustup run nightly cargo run -- --ir examples/fibonacci.sl
</code></pre>
<p>Output:</p>
<pre><code class="language-llvm">; ModuleID = 'secondlang'
source_filename = "secondlang"

define i64 @fib(i64 %n) {
entry:
  ; ... the generated IR
}

define i64 @__main() {
entry:
  %call = call i64 @fib(i64 10)
  ret i64 %call
}
</code></pre>
<p>Notice the <code>@__main</code> function. This is a wrapper we generate for top-level expressions. When you write <code>fib(10)</code> at the top level, we wrap it in <code>__main</code> so the JIT has something to call.</p>
<h2 id="further-reading-2"><a class="header" href="#further-reading-2">Further Reading</a></h2>
<ul>
<li><a href="https://llvm.org/docs/LangRef.html">LLVM Language Reference</a> - the official specification</li>
<li><a href="https://en.wikipedia.org/wiki/Static_single-assignment_form">SSA on Wikipedia</a> - the theory behind SSA</li>
<li><a href="https://llvm.org/docs/tutorial/">LLVM Tutorial: Kaleidoscope</a> - LLVM’s own tutorial (in C++)</li>
<li><a href="https://github.com/TheDan64/inkwell">inkwell</a> - the Rust bindings we use</li>
</ul>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>LLVM IR key concepts:</p>
<ul>
<li><strong>Low-level</strong> - close to assembly, explicit about memory operations</li>
<li><strong>Typed</strong> - every value has a type (<code>i64</code>, <code>i1</code>, <code>ptr</code>, etc.)</li>
<li><strong>SSA form</strong> - each variable is assigned exactly once</li>
<li><strong>Basic blocks</strong> - sequences of instructions ending with a terminator (<code>ret</code>, <code>br</code>)</li>
<li><strong>Phi nodes</strong> - merge values from different control flow paths</li>
<li><strong>Platform-independent</strong> - LLVM handles the CPU-specific details</li>
</ul>
<p>In the next chapter, we write the <a href="03_secondlang/./codegen.html">code generator</a> that produces this IR from our typed AST.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="llvm-code-generation"><a class="header" href="#llvm-code-generation">LLVM Code Generation</a></h1>
<p>Now we write the code that turns our typed AST into LLVM IR. We use the <strong>inkwell</strong> library, which provides safe Rust bindings to LLVM.</p>
<h2 id="the-codegen-structure"><a class="header" href="#the-codegen-structure">The CodeGen Structure</a></h2>
<p>Our code generator keeps track of several things:</p>
<pre><code class="language-rust ignore">/// Code generator state
pub struct CodeGen&lt;'ctx&gt; {
    context: &amp;'ctx Context,
    module: Module&lt;'ctx&gt;,
    builder: Builder&lt;'ctx&gt;,
    /// Map from variable names to their stack allocations
    variables: HashMap&lt;String, PointerValue&lt;'ctx&gt;&gt;,
    /// Map from function names to LLVM functions
    functions: HashMap&lt;String, FunctionValue&lt;'ctx&gt;&gt;,
    /// Current function being compiled
    current_fn: Option&lt;FunctionValue&lt;'ctx&gt;&gt;,
}</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/secondlang/src/codegen.rs">secondlang/src/codegen.rs</a></p>
<p>Let us understand each field:</p>
<ul>
<li><strong>context</strong> - The LLVM context. All LLVM objects belong to a context. Think of it as the “workspace” for LLVM.</li>
<li><strong>module</strong> - A container for functions. Think of it as a single source file or compilation unit.</li>
<li><strong>builder</strong> - The tool we use to create IR instructions. We position it in a basic block and it adds instructions there.</li>
<li><strong>variables</strong> - Maps variable names to their stack locations (pointers from <code>alloca</code>). When we see <code>x</code>, we look it up here to find where it lives in memory.</li>
<li><strong>functions</strong> - Maps function names to their LLVM function objects. Needed so we can call functions by name.</li>
<li><strong>current_fn</strong> - The function we are currently compiling. Needed to create new basic blocks for conditionals and loops.</li>
</ul>
<h2 id="the-compilation-process"><a class="header" href="#the-compilation-process">The Compilation Process</a></h2>
<p>Compilation happens in three passes:</p>
<pre><code class="language-rust ignore">    /// Compile a program and return the module
    pub fn compile(&amp;mut self, program: &amp;Program) -&gt; Result&lt;(), String&gt; {
        // First pass: declare all functions
        for stmt in program {
            if let Stmt::Function {
                name,
                params,
                return_type,
                ..
            } = stmt
            {
                self.declare_function(name, params, return_type)?;
            }
        }

        // Second pass: compile function bodies only (not top-level expressions)
        for stmt in program {
            if let Stmt::Function { .. } = stmt {
                self.compile_stmt(stmt)?;
            }
        }

        // Third pass: create __main wrapper for top-level expression
        if let Some(Stmt::Expr(expr)) = program.last() {
            self.compile_main_wrapper(expr)?;
        }

        // Verify module
        self.module
            .verify()
            .map_err(|e| format!("Module verification failed: {}", e.to_string()))?;

        Ok(())
    }</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/secondlang/src/codegen.rs">secondlang/src/codegen.rs</a></p>
<p><strong>Pass 1: Declare all functions</strong></p>
<p>Before we can compile function bodies, we need to know about all functions. Why? Because <code>foo</code> might call <code>bar</code>, and <code>bar</code> might call <code>foo</code>. We declare all functions first so calls can find their targets.</p>
<p>A function <em>declaration</em> tells LLVM “there is a function with this name and signature” but does not include the body yet.</p>
<p><strong>Pass 2: Compile function bodies</strong></p>
<p>Now we go through each function and generate its body - the actual instructions.</p>
<p><strong>Pass 3: Create the <code>__main</code> wrapper</strong></p>
<p>If there is a top-level expression (like <code>fib(10)</code>), we wrap it in a <code>__main</code> function. This gives the JIT an entry point to call.</p>
<p><strong>Verify the module</strong></p>
<p>Finally, we ask LLVM to verify that our IR is well-formed. This catches bugs in our code generator.</p>
<h2 id="compiling-expressions"><a class="header" href="#compiling-expressions">Compiling Expressions</a></h2>
<p>The heart of code generation is <code>compile_expr</code>. It takes a typed expression and produces an LLVM value:</p>
<pre><code class="language-rust ignore">    /// Compile an expression
    fn compile_expr(&amp;mut self, expr: &amp;TypedExpr) -&gt; Result&lt;IntValue&lt;'ctx&gt;, String&gt; {
        match &amp;expr.expr {
            Expr::Int(n) =&gt; Ok(self.context.i64_type().const_int(*n as u64, false)),

            Expr::Bool(b) =&gt; Ok(self.context.bool_type().const_int(*b as u64, false)),

            Expr::Var(name) =&gt; {
                let ptr = self
                    .variables
                    .get(name)
                    .ok_or_else(|| format!("Undefined variable: {}", name))?;
                let val = self
                    .builder
                    .build_load(self.context.i64_type(), *ptr, name)
                    .unwrap();
                Ok(val.into_int_value())
            }

            Expr::Unary { op, expr: inner } =&gt; {
                let val = self.compile_expr(inner)?;
                match op {
                    UnaryOp::Neg =&gt; Ok(self.builder.build_int_neg(val, "neg").unwrap()),
                    UnaryOp::Not =&gt; Ok(self.builder.build_not(val, "not").unwrap()),
                }
            }

            Expr::Binary { op, left, right } =&gt; {
                let l = self.compile_expr(left)?;
                let r = self.compile_expr(right)?;

                match op {
                    BinaryOp::Add =&gt; Ok(self.builder.build_int_add(l, r, "add").unwrap()),
                    BinaryOp::Sub =&gt; Ok(self.builder.build_int_sub(l, r, "sub").unwrap()),
                    BinaryOp::Mul =&gt; Ok(self.builder.build_int_mul(l, r, "mul").unwrap()),
                    BinaryOp::Div =&gt; Ok(self.builder.build_int_signed_div(l, r, "div").unwrap()),
                    BinaryOp::Mod =&gt; Ok(self.builder.build_int_signed_rem(l, r, "mod").unwrap()),
                    BinaryOp::Lt =&gt; {
                        let cmp = self
                            .builder
                            .build_int_compare(IntPredicate::SLT, l, r, "lt")
                            .unwrap();
                        Ok(self
                            .builder
                            .build_int_z_extend(cmp, self.context.i64_type(), "ext")
                            .unwrap())
                    }
                    BinaryOp::Gt =&gt; {
                        let cmp = self
                            .builder
                            .build_int_compare(IntPredicate::SGT, l, r, "gt")
                            .unwrap();
                        Ok(self
                            .builder
                            .build_int_z_extend(cmp, self.context.i64_type(), "ext")
                            .unwrap())
                    }
                    BinaryOp::Le =&gt; {
                        let cmp = self
                            .builder
                            .build_int_compare(IntPredicate::SLE, l, r, "le")
                            .unwrap();
                        Ok(self
                            .builder
                            .build_int_z_extend(cmp, self.context.i64_type(), "ext")
                            .unwrap())
                    }
                    BinaryOp::Ge =&gt; {
                        let cmp = self
                            .builder
                            .build_int_compare(IntPredicate::SGE, l, r, "ge")
                            .unwrap();
                        Ok(self
                            .builder
                            .build_int_z_extend(cmp, self.context.i64_type(), "ext")
                            .unwrap())
                    }
                    BinaryOp::Eq =&gt; {
                        let cmp = self
                            .builder
                            .build_int_compare(IntPredicate::EQ, l, r, "eq")
                            .unwrap();
                        Ok(self
                            .builder
                            .build_int_z_extend(cmp, self.context.i64_type(), "ext")
                            .unwrap())
                    }
                    BinaryOp::Ne =&gt; {
                        let cmp = self
                            .builder
                            .build_int_compare(IntPredicate::NE, l, r, "ne")
                            .unwrap();
                        Ok(self
                            .builder
                            .build_int_z_extend(cmp, self.context.i64_type(), "ext")
                            .unwrap())
                    }
                }
            }

            Expr::Call { name, args } =&gt; {
                let function = self
                    .functions
                    .get(name)
                    .cloned()
                    .ok_or_else(|| format!("Undefined function: {}", name))?;

                let arg_values: Vec&lt;BasicMetadataValueEnum&gt; = args
                    .iter()
                    .map(|a| self.compile_expr(a).map(|v| v.into()))
                    .collect::&lt;Result&lt;_, _&gt;&gt;()?;

                let call = self
                    .builder
                    .build_call(function, &amp;arg_values, "call")
                    .unwrap();
                Ok(call.try_as_basic_value().unwrap_basic().into_int_value())
            }

            Expr::If {
                cond,
                then_branch,
                else_branch,
            } =&gt; {
                let cond_val = self.compile_expr(cond)?;
                // Convert to i1 for branch
                let cond_bool = self
                    .builder
                    .build_int_truncate(cond_val, self.context.bool_type(), "cond")
                    .unwrap();

                let function = self.current_fn.unwrap();
                let then_bb = self.context.append_basic_block(function, "then");
                let else_bb = self.context.append_basic_block(function, "else");
                let merge_bb = self.context.append_basic_block(function, "merge");

                self.builder
                    .build_conditional_branch(cond_bool, then_bb, else_bb)
                    .unwrap();

                // Then branch
                self.builder.position_at_end(then_bb);
                let mut then_val = self.context.i64_type().const_int(0, false);
                for stmt in then_branch {
                    if let Some(v) = self.compile_stmt(stmt)? {
                        then_val = v;
                    }
                }
                let then_end = self.builder.get_insert_block().unwrap();
                let then_has_terminator = then_end.get_terminator().is_some();
                if !then_has_terminator {
                    self.builder.build_unconditional_branch(merge_bb).unwrap();
                }

                // Else branch
                self.builder.position_at_end(else_bb);
                let mut else_val = self.context.i64_type().const_int(0, false);
                for stmt in else_branch {
                    if let Some(v) = self.compile_stmt(stmt)? {
                        else_val = v;
                    }
                }
                let else_end = self.builder.get_insert_block().unwrap();
                let else_has_terminator = else_end.get_terminator().is_some();
                if !else_has_terminator {
                    self.builder.build_unconditional_branch(merge_bb).unwrap();
                }

                // Merge - only if at least one branch reaches it
                if then_has_terminator &amp;&amp; else_has_terminator {
                    // Both branches return/terminate, merge block is unreachable
                    // Remove it and return a dummy value
                    unsafe {
                        merge_bb.delete().unwrap();
                    }
                    // Return a dummy value - the actual return happened in the branches
                    Ok(self.context.i64_type().const_int(0, false))
                } else {
                    self.builder.position_at_end(merge_bb);
                    let phi = self
                        .builder
                        .build_phi(self.context.i64_type(), "phi")
                        .unwrap();

                    // Only add incoming from branches that don't have terminators
                    if !then_has_terminator {
                        phi.add_incoming(&amp;[(&amp;then_val, then_end)]);
                    }
                    if !else_has_terminator {
                        phi.add_incoming(&amp;[(&amp;else_val, else_end)]);
                    }

                    Ok(phi.as_basic_value().into_int_value())
                }
            }

            Expr::While { cond, body } =&gt; {
                let function = self.current_fn.unwrap();
                let cond_bb = self.context.append_basic_block(function, "while_cond");
                let body_bb = self.context.append_basic_block(function, "while_body");
                let end_bb = self.context.append_basic_block(function, "while_end");

                self.builder.build_unconditional_branch(cond_bb).unwrap();

                // Condition
                self.builder.position_at_end(cond_bb);
                let cond_val = self.compile_expr(cond)?;
                let cond_bool = self
                    .builder
                    .build_int_truncate(cond_val, self.context.bool_type(), "cond")
                    .unwrap();
                self.builder
                    .build_conditional_branch(cond_bool, body_bb, end_bb)
                    .unwrap();

                // Body
                self.builder.position_at_end(body_bb);
                for stmt in body {
                    self.compile_stmt(stmt)?;
                }
                if self
                    .builder
                    .get_insert_block()
                    .unwrap()
                    .get_terminator()
                    .is_none()
                {
                    self.builder.build_unconditional_branch(cond_bb).unwrap();
                }

                // End
                self.builder.position_at_end(end_bb);
                Ok(self.context.i64_type().const_int(0, false))
            }

            Expr::Block(stmts) =&gt; {
                let mut last_val = self.context.i64_type().const_int(0, false);
                for stmt in stmts {
                    if let Some(v) = self.compile_stmt(stmt)? {
                        last_val = v;
                    }
                }
                Ok(last_val)
            }
        }
    }</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/secondlang/src/codegen.rs">secondlang/src/codegen.rs</a></p>
<p>Let us walk through the important cases:</p>
<h3 id="integers-and-booleans"><a class="header" href="#integers-and-booleans">Integers and Booleans</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Expr::Int(n) =&gt; Ok(self.context.i64_type().const_int(*n as u64, false)),
Expr::Bool(b) =&gt; Ok(self.context.bool_type().const_int(*b as u64, false)),
<span class="boring">}</span></code></pre></pre>
<p>Constants are simple. We create a constant integer value of the right type. The <code>false</code> argument means the value is unsigned (we use signed arithmetic in operations).</p>
<h3 id="variables-the-allocaload-pattern"><a class="header" href="#variables-the-allocaload-pattern">Variables: The Alloca/Load Pattern</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Expr::Var(name) =&gt; {
    let ptr = self.variables.get(name)
        .ok_or_else(|| format!("Undefined variable: {}", name))?;
    let val = self.builder.build_load(self.context.i64_type(), *ptr, name)?;
    Ok(val.into_int_value())
}
<span class="boring">}</span></code></pre></pre>
<p>Variables are stored on the stack using the <strong>alloca/load/store pattern</strong> we discussed in the <a href="03_secondlang/./ir.html#why-all-the-loading-and-storing">IR chapter</a>:</p>
<ol>
<li>When we declare a variable, we use <code>alloca</code> to reserve stack space and store the pointer</li>
<li>When we read a variable, we <code>load</code> from that pointer</li>
<li>When we write a variable, we <code>store</code> to that pointer</li>
</ol>
<p>This pattern handles mutable variables naturally and LLVM optimizes it away when possible (promoting stack slots to registers).</p>
<h3 id="binary-operations"><a class="header" href="#binary-operations">Binary Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Expr::Binary { op, left, right } =&gt; {
    let l = self.compile_expr(left)?;  // compile left operand
    let r = self.compile_expr(right)?; // compile right operand

    match op {
        BinaryOp::Add =&gt; Ok(self.builder.build_int_add(l, r, "add")?),
        BinaryOp::Sub =&gt; Ok(self.builder.build_int_sub(l, r, "sub")?),
        // ... etc
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We recursively compile left and right operands, then emit the appropriate instruction. The <code>"add"</code> string is a name for the result (helps when reading the IR).</p>
<h3 id="function-calls"><a class="header" href="#function-calls">Function Calls</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Expr::Call { name, args } =&gt; {
    let function = self.functions.get(name)
        .ok_or_else(|| format!("Undefined function: {}", name))?;

    let arg_values: Vec&lt;_&gt; = args.iter()
        .map(|a| self.compile_expr(a).map(|v| v.into()))
        .collect::&lt;Result&lt;_, _&gt;&gt;()?;

    let call = self.builder.build_call(*function, &amp;arg_values, "call")?;
    Ok(call.try_as_basic_value().unwrap_basic().into_int_value())
}
<span class="boring">}</span></code></pre></pre>
<p>We look up the function, compile each argument, then emit a <code>call</code> instruction.</p>
<p>The <code>try_as_basic_value().unwrap_basic()</code> deserves explanation. In LLVM, function calls can return either:</p>
<ul>
<li>A “basic value” (like an integer or pointer) that we can use</li>
<li>Nothing (for void functions)</li>
</ul>
<p><code>try_as_basic_value()</code> returns an enum with both possibilities. Since our functions always return <code>int</code>, we know we have a basic value and can safely unwrap it. The <code>into_int_value()</code> converts it to the specific integer type we need.</p>
<h3 id="conditionals-1"><a class="header" href="#conditionals-1">Conditionals</a></h3>
<p>Conditionals need multiple basic blocks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Expr::If { cond, then_branch, else_branch } =&gt; {
    // Compile condition and convert to i1 for branching
    let cond_val = self.compile_expr(cond)?;
    let cond_bool = self.builder.build_int_truncate(cond_val, self.context.bool_type(), "cond")?;

    // Create basic blocks for then, else, and merge
    let function = self.current_fn.unwrap();
    let then_bb = self.context.append_basic_block(function, "then");
    let else_bb = self.context.append_basic_block(function, "else");
    let merge_bb = self.context.append_basic_block(function, "merge");

    // Branch based on condition
    self.builder.build_conditional_branch(cond_bool, then_bb, else_bb)?;

    // Compile then branch
    self.builder.position_at_end(then_bb);
    // ... compile statements ...
    self.builder.build_unconditional_branch(merge_bb)?;

    // Compile else branch
    self.builder.position_at_end(else_bb);
    // ... compile statements ...
    self.builder.build_unconditional_branch(merge_bb)?;

    // Continue at merge point
    self.builder.position_at_end(merge_bb);
    // ... use phi node to select result ...
}
<span class="boring">}</span></code></pre></pre>
<p>The key insight: we create separate basic blocks, compile each branch by positioning the builder at the right block, then use a <strong>phi node</strong> to merge the results.</p>
<p>Remember from the <a href="03_secondlang/./ir.html#phi-nodes-merging-values-from-different-paths">IR chapter</a>: a phi node selects a value based on which block we came from. If the condition was true and we came from <code>then_bb</code>, use the then-result. Otherwise use the else-result.</p>
<h2 id="jit-execution"><a class="header" href="#jit-execution">JIT Execution</a></h2>
<p>Finally, we can run our compiled code:</p>
<pre><code class="language-rust ignore">/// JIT compile and run a program
pub fn jit_run(program: &amp;Program) -&gt; Result&lt;i64, String&gt; {
    let context = Context::create();
    let mut codegen = CodeGen::new(&amp;context, "secondlang");

    codegen.compile(program)?;

    // Create execution engine
    let engine = codegen
        .module
        .create_jit_execution_engine(OptimizationLevel::Default)
        .map_err(|e| format!("Failed to create JIT: {}", e.to_string()))?;

    // Call the __main wrapper function which contains the top-level expression
    unsafe {
        let func: inkwell::execution_engine::JitFunction&lt;unsafe extern "C" fn() -&gt; i64&gt; =
            engine.get_function("__main").map_err(|e| e.to_string())?;
        Ok(func.call())
    }
}</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/secondlang/src/codegen.rs">secondlang/src/codegen.rs</a></p>
<p>This function:</p>
<ol>
<li>Creates a code generator</li>
<li>Compiles the program to IR</li>
<li>Creates a JIT execution engine</li>
<li>Gets a pointer to <code>__main</code> (our entry point)</li>
<li>Calls it and returns the result</li>
</ol>
<p>The JIT engine compiles our IR to native machine code on the fly, then executes it. This is much faster than interpretation because we are running actual machine code, not walking a tree.</p>
<p>The <code>unsafe</code> block is required because we are calling raw machine code. We have to trust that our code generator produced valid code.</p>
<h2 id="putting-it-all-together"><a class="header" href="#putting-it-all-together">Putting It All Together</a></h2>
<p>Here is what happens when you run <code>cargo run -- examples/fibonacci.sl</code>:</p>
<ol>
<li><strong>Parse</strong> the source file → Typed AST (with <code>Unknown</code> types)</li>
<li><strong>Type check</strong> → Typed AST (all types resolved)</li>
<li><strong>Optimize</strong> (optional) → Simplified AST</li>
<li><strong>Compile</strong> → LLVM IR</li>
<li><strong>JIT</strong> → Native machine code</li>
<li><strong>Execute</strong> → Result</li>
</ol>
<p>All in a fraction of a second.</p>
<h2 id="testing-2"><a class="header" href="#testing-2">Testing</a></h2>
<pre><code class="language-bash">cargo test codegen
</code></pre>
<p>In the next chapter, we put it all together and run Fibonacci.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jit-compiling-fibonacci"><a class="header" href="#jit-compiling-fibonacci">JIT Compiling Fibonacci</a></h1>
<p>We have built all the pieces. Now let us put them together and run some real programs.</p>
<h2 id="the-complete-pipeline"><a class="header" href="#the-complete-pipeline">The Complete Pipeline</a></h2>
<p>Here is what happens when you run a Secondlang program:</p>
<pre><code>Source Code: def fib(n: int) -&gt; int { ... }; fib(10)
                              |
                          [Parser]
                              |
              Typed AST (types are Unknown)
                              |
                        [Type Checker]
                              |
              Typed AST (all types filled in)
                              |
                    [Optimizer (optional)]
                              |
                      [Code Generator]
                              |
                          LLVM IR
                              |
                        [JIT Engine]
                              |
                      Native Machine Code
                              |
                          [Execute]
                              |
                         Result: 55
</code></pre>
<p>Each step transforms the program into a different representation, getting closer and closer to something the CPU can execute.</p>
<h2 id="running-fibonacci"><a class="header" href="#running-fibonacci">Running Fibonacci</a></h2>
<p>Create a file <code>examples/fibonacci.sl</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>def fib(n: int) -&gt; int {
    if (n &lt; 2) {
        return n
    } else {
        return fib(n - 1) + fib(n - 2)
    }
}

fib(10)
<span class="boring">}</span></code></pre></pre>
<p>Run it:</p>
<pre><code class="language-bash">cd secondlang
rustup run nightly cargo run -- examples/fibonacci.sl
</code></pre>
<p>Output:</p>
<pre><code>55
</code></pre>
<p>It works. We just JIT compiled recursive Fibonacci to native code and ran it.</p>
<h2 id="viewing-the-generated-ir"><a class="header" href="#viewing-the-generated-ir">Viewing the Generated IR</a></h2>
<p>Want to see what LLVM IR your program compiles to?</p>
<pre><code class="language-bash">rustup run nightly cargo run -- --ir examples/fibonacci.sl
</code></pre>
<p>You will see something like:</p>
<pre><code class="language-llvm">; ModuleID = 'secondlang'
source_filename = "secondlang"

define i64 @fib(i64 %n) {
entry:
  %n1 = alloca i64, align 8
  store i64 %n, ptr %n1, align 4
  %n2 = load i64, ptr %n1, align 4
  %lt = icmp slt i64 %n2, 2
  %ext = zext i1 %lt to i64
  %cond = trunc i64 %ext to i1
  br i1 %cond, label %then, label %else

then:
  %n3 = load i64, ptr %n1, align 4
  ret i64 %n3

else:
  %n4 = load i64, ptr %n1, align 4
  %sub = sub i64 %n4, 1
  %call = call i64 @fib(i64 %sub)
  %n5 = load i64, ptr %n1, align 4
  %sub6 = sub i64 %n5, 2
  %call7 = call i64 @fib(i64 %sub6)
  %add = add i64 %call, %call7
  ret i64 %add
}

define i64 @__main() {
entry:
  %call = call i64 @fib(i64 10)
  ret i64 %call
}
</code></pre>
<p>You can see:</p>
<ul>
<li>The <code>@fib</code> function with its recursion</li>
<li>The <code>@__main</code> wrapper that calls <code>fib(10)</code></li>
<li>All the loads and stores for local variables</li>
<li>The branching for the if/else</li>
</ul>
<h2 id="more-examples-1"><a class="header" href="#more-examples-1">More Examples</a></h2>
<h3 id="factorial"><a class="header" href="#factorial">Factorial</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>def factorial(n: int) -&gt; int {
    if (n &lt;= 1) {
        return 1
    } else {
        return n * factorial(n - 1)
    }
}

factorial(20)
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-bash">rustup run nightly cargo run -- examples/factorial.sl
2432902008176640000
</code></pre>
<h3 id="type-inference-1"><a class="header" href="#type-inference-1">Type Inference</a></h3>
<p>This example shows the compiler inferring types automatically:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>def complex_calc(x: int) -&gt; int {
    a = x + 1           # int (inferred from x + literal)
    b = a * a           # int (inferred from int * int)
    c = b - x           # int (inferred from int - int)
    flag = c &gt; 100      # bool (inferred from comparison)
    if (flag) {
        return c
    } else {
        return b
    }
}

complex_calc(10)
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-bash">rustup run nightly cargo run -- examples/inference.sl
111
</code></pre>
<h2 id="what-we-built"><a class="header" href="#what-we-built">What We Built</a></h2>
<p>Let us step back and appreciate what we have accomplished. Starting from scratch, we built:</p>
<ol>
<li><strong>A parser</strong> using PEG grammar (pest) - turns source code into AST (see <a href="03_secondlang/./annotations.html">Type Annotations</a>)</li>
<li><strong>A type system</strong> with inference - catches errors at compile time (see <a href="03_secondlang/./inference.html">Type Inference</a>)</li>
<li><strong>Optimization passes</strong> using the visitor pattern - simplifies the AST (see <a href="03_secondlang/./optimizations.html">AST Optimizations</a>)</li>
<li><strong>An LLVM code generator</strong> (inkwell) - produces IR from the typed AST (see <a href="03_secondlang/./codegen.html">Code Generation</a>)</li>
<li><strong>JIT compilation</strong> - compiles IR to native code and runs it (see <a href="03_secondlang/./ir.html">From AST to IR</a>)</li>
</ol>
<p>All in about 1500 lines of Rust.</p>
<h2 id="comparing-the-three-languages"><a class="header" href="#comparing-the-three-languages">Comparing the Three Languages</a></h2>
<p>See how we progressed through each language:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th><a href="03_secondlang/../01_calculator/calc_intro.html">Calculator</a></th><th><a href="03_secondlang/../02_firstlang/intro.html">Firstlang</a></th><th>Secondlang</th></tr></thead><tbody>
<tr><td>Grammar</td><td>18 lines</td><td>70 lines</td><td>77 lines</td></tr>
<tr><td>Type System</td><td>None</td><td>Dynamic</td><td>Static</td></tr>
<tr><td>Type Annotations</td><td>None</td><td>None</td><td><code>x: int</code>, <code>-&gt; int</code></td></tr>
<tr><td>Functions</td><td>No</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Recursion</td><td>No</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Execution</td><td>Interpreter/VM/JIT</td><td>Tree-walking interpreter</td><td>LLVM JIT</td></tr>
</tbody></table>
</div>
<p>The progression is clear:</p>
<ol>
<li><strong><a href="03_secondlang/../01_calculator/calc_intro.html">Calculator</a></strong> - Learn the basics with the simplest possible language</li>
<li><strong><a href="03_secondlang/../02_firstlang/intro.html">Firstlang</a></strong> - Add programming constructs, understand interpretation</li>
<li><strong>Secondlang</strong> - Add types, understand compilation</li>
</ol>
<h2 id="what-next"><a class="header" href="#what-next">What Next?</a></h2>
<p>You now have the foundation to build real programming languages. Some ideas to explore:</p>
<ul>
<li><strong>Add more types</strong>: strings, arrays, structs</li>
<li><strong>Add closures</strong>: functions that capture variables</li>
<li><strong>Add garbage collection</strong>: automatic memory management</li>
<li><strong>AOT compilation</strong>: compile to executables instead of JIT</li>
<li><strong>Better error messages</strong>: with source locations and suggestions</li>
</ul>
<p>The concepts you learned here - grammars, parsing, ASTs, type checking, code generation - apply to any language you might want to build.</p>
<p>Happy hacking.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resources"><a class="header" href="#resources">Resources</a></h1>
<h2 id="books"><a class="header" href="#books">Books</a></h2>
<ul>
<li>
<p><strong>Crafting Interpreters</strong> by Robert Nystrom</p>
<ul>
<li>Excellent, free online book: <a href="https://craftinginterpreters.com">craftinginterpreters.com</a></li>
<li>Covers tree-walking interpreters and bytecode VMs</li>
</ul>
</li>
<li>
<p><strong>Writing an Interpreter in Go</strong> by Thorsten Ball</p>
<ul>
<li>Practical, hands-on approach</li>
</ul>
</li>
<li>
<p><strong>Engineering a Compiler</strong> by Cooper &amp; Torczon</p>
<ul>
<li>Comprehensive academic textbook</li>
</ul>
</li>
</ul>
<h2 id="rust-resources"><a class="header" href="#rust-resources">Rust Resources</a></h2>
<ul>
<li>
<p><strong>The Rust Programming Language</strong> (“The Book”)</p>
<ul>
<li><a href="https://doc.rust-lang.org/book">doc.rust-lang.org/book</a></li>
</ul>
</li>
<li>
<p><strong>Rust by Example</strong></p>
<ul>
<li><a href="https://doc.rust-lang.org/rust-by-example">doc.rust-lang.org/rust-by-example</a></li>
</ul>
</li>
</ul>
<h2 id="tools-used"><a class="header" href="#tools-used">Tools Used</a></h2>
<ul>
<li>
<p><strong>pest</strong> - PEG parser generator for Rust</p>
<ul>
<li><a href="https://pest.rs">pest.rs</a></li>
<li><a href="https://docs.rs/pest">docs.rs/pest</a></li>
</ul>
</li>
<li>
<p><strong>inkwell</strong> - Safe LLVM wrapper for Rust</p>
<ul>
<li><a href="https://github.com/TheDan64/inkwell">github.com/TheDan64/inkwell</a></li>
</ul>
</li>
<li>
<p><strong>LLVM</strong> - Compiler infrastructure</p>
<ul>
<li><a href="https://llvm.org">llvm.org</a></li>
<li><a href="https://llvm.org/docs/LangRef.html">llvm.org/docs/LangRef.html</a> - LLVM IR reference</li>
</ul>
</li>
</ul>
<h2 id="academic-papers"><a class="header" href="#academic-papers">Academic Papers</a></h2>
<ul>
<li><strong>A Nanopass Framework for Compiler Education</strong> - Sarkar, Waddell, Dybvig</li>
<li><strong>Linear Scan Register Allocation</strong> - Poletto, Sarkar</li>
<li><strong>Simple and Efficient Construction of SSA Form</strong> - Braun et al.</li>
</ul>
<h2 id="community"><a class="header" href="#community">Community</a></h2>
<ul>
<li><strong>r/ProgrammingLanguages</strong> on Reddit</li>
<li><strong>Programming Languages</strong> Discord servers</li>
<li><strong>Rust Users Forum</strong> - <a href="https://users.rust-lang.org">users.rust-lang.org</a></li>
</ul>
<h2 id="source-code"><a class="header" href="#source-code">Source Code</a></h2>
<p>All code for this book:</p>
<ul>
<li><a href="https://github.com/ehsanmok/create-your-own-lang-with-rust">github.com/ehsanmok/create-your-own-lang-with-rust</a></li>
</ul>
<p>File issues or contribute!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/force-theme.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
