<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>AST Traversal Patterns - Create Your Own Programming Language with Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">
        <link rel="stylesheet" href="../theme/highlight.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Create Your Own Programming Language with Rust</h1>

                    <div class="right-buttons">
                        <a href="https://github.com/ehsanmok/create-your-own-lang-with-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="ast-traversal-patterns"><a class="header" href="#ast-traversal-patterns">AST Traversal Patterns</a></h2>
<p>In the <a href="./basic_llvm.html">previous section</a>, we handcrafted every LLVM instruction for a simple <code>add</code> function. That worked, but it was tedious - imagine doing that for every possible expression! We need a systematic way to turn <em>any</em> AST into LLVM IR.</p>
<p>The answer is <strong>recursive tree traversal</strong>. We already do this in the interpreter - walk the tree, evaluate each node. For code generation, we walk the tree and <em>emit instructions</em> for each node instead of computing values.</p>
<p>Two common patterns help structure this:</p>
<ul>
<li><strong>Builder pattern</strong> - Used here for LLVM IR generation</li>
<li><strong>Visitor pattern</strong> - Introduced in <a href="../03_secondlang/optimizations.html">Secondlang Optimizations</a> for AST transformations</li>
</ul>
<h3 id="builder-pattern"><a class="header" href="#builder-pattern">Builder Pattern</a></h3>
<p>Think of the LLVM builder like a cursor in a text editor. You position it somewhere in your code, then “type” instructions at that position. The builder keeps track of where you are and ensures instructions are added in the right place.</p>
<p>Let’s compare our interpreter’s recursive evaluation to the new JIT approach.</p>
<p><strong>Interpreter</strong>: Walk tree, compute values</p>
<pre><code class="language-rust no_run noplaypen">struct Eval;

impl Eval {
    pub fn new() -&gt; Self {
        Self
    }
    pub fn eval(&amp;self, node: &amp;Node) -&gt; i32 {
        match node {
            Node::Int(n) =&gt; *n,
            Node::UnaryExpr { op, child } =&gt; {
                let child = self.eval(child);
                match op {
                    Operator::Plus =&gt; child,
                    Operator::Minus =&gt; -child,
                }
            }
            Node::BinaryExpr { op, lhs, rhs } =&gt; {
                let lhs_ret = self.eval(lhs);
                let rhs_ret = self.eval(rhs);

                match op {
                    Operator::Plus =&gt; lhs_ret + rhs_ret,
                    Operator::Minus =&gt; lhs_ret - rhs_ret,
                }
            }
        }
    }
}</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/calculator/src/compiler/interpreter.rs">calculator/src/compiler/interpreter.rs</a></p>
<p>The interpreter looks at each node and returns a computed integer. For <code>Int(5)</code>, it returns <code>5</code>. For <code>Binary { op: Add, left: Int(1), right: Int(2) }</code>, it recursively evaluates both sides and adds them.</p>
<p><strong>JIT</strong>: Walk tree, emit LLVM instructions</p>
<pre><code class="language-rust no_run noplaypen">struct RecursiveBuilder&lt;'a&gt; {
    i32_type: IntType&lt;'a&gt;,
    builder: &amp;'a Builder&lt;'a&gt;,
}

impl&lt;'a&gt; RecursiveBuilder&lt;'a&gt; {
    pub fn new(i32_type: IntType&lt;'a&gt;, builder: &amp;'a Builder) -&gt; Self {
        Self { i32_type, builder }
    }
    pub fn build(&amp;self, ast: &amp;Node) -&gt; IntValue&lt;'a&gt; {
        match ast {
            Node::Int(n) =&gt; self.i32_type.const_int(*n as u64, true),
            Node::UnaryExpr { op, child } =&gt; {
                let child = self.build(child);
                match op {
                    Operator::Minus =&gt; child.const_neg(),
                    Operator::Plus =&gt; child,
                }
            }
            Node::BinaryExpr { op, lhs, rhs } =&gt; {
                let left = self.build(lhs);
                let right = self.build(rhs);

                match op {
                    Operator::Plus =&gt; self
                        .builder
                        .build_int_add(left, right, "plus_temp")
                        .unwrap(),
                    Operator::Minus =&gt; self
                        .builder
                        .build_int_sub(left, right, "minus_temp")
                        .unwrap(),
                }
            }
        }
    }
}</code></pre>
<p>The structure is identical! We still match on node types and recurse. But instead of computing values directly, we build LLVM instructions:</p>
<ul>
<li>
<p><strong><code>Int(n)</code></strong> - Create an LLVM integer constant. This doesn’t “do” anything at compile time - it creates a value that will exist when the code runs.</p>
</li>
<li>
<p><strong><code>UnaryExpr</code></strong> - For negation, we recursively compile the inner expression (getting an LLVM value), then emit a subtraction from zero. In LLVM, <code>-x</code> is typically represented as <code>0 - x</code>.</p>
</li>
<li>
<p><strong><code>BinaryExpr</code></strong> - Recursively compile both sides, then emit the appropriate arithmetic instruction (<code>build_int_add</code>, <code>build_int_sub</code>). The <code>"add"</code> and <code>"sub"</code> strings are just names for debugging - they show up when you print the IR.</p>
</li>
</ul>
<p>The key insight: <code>recursive_builder</code> returns LLVM <em>values</em>, not Rust integers. These values represent computation that will happen when the JIT-compiled code runs.</p>
<h3 id="putting-it-together"><a class="header" href="#putting-it-together">Putting It Together</a></h3>
<p>Now we wire up the complete JIT pipeline:</p>
<pre><code class="language-rust no_run noplaypen">pub struct Jit;

impl Compile for Jit {
    type Output = Result&lt;i32&gt;;

    fn from_ast(ast: Vec&lt;Node&gt;) -&gt; Self::Output {
        let context = Context::create();
        let module = context.create_module("calculator");

        let builder = context.create_builder();

        let execution_engine = module
            .create_jit_execution_engine(OptimizationLevel::None)
            .unwrap();

        let i32_type = context.i32_type();
        let fn_type = i32_type.fn_type(&amp;[], false);

        let function = module.add_function("jit", fn_type, None);
        let basic_block = context.append_basic_block(function, "entry");

        builder.position_at_end(basic_block);

        for node in ast {
            let recursive_builder = RecursiveBuilder::new(i32_type, &amp;builder);
            let return_value = recursive_builder.build(&amp;node);
            let _ = builder.build_return(Some(&amp;return_value));
        }
        println!(
            "Generated LLVM IR: {}",
            function.print_to_string().to_string()
        );

        unsafe {
            let jit_function: JitFunction&lt;JitFunc&gt; = execution_engine.get_function("jit").unwrap();

            Ok(jit_function.call())
        }
    }
}</code></pre>
<p><a class="filename" href="https://github.com/ehsanmok/create-your-own-lang-with-rust/blob/master/calculator/src/compiler/jit.rs">calculator/src/compiler/jit.rs</a></p>
<p>Let’s trace through what happens when we JIT <code>1 + 2</code>:</p>
<ol>
<li>
<p><strong>Parse</strong> - Turn <code>"1 + 2"</code> into AST: <code>Binary { op: Add, left: Int(1), right: Int(2) }</code></p>
</li>
<li>
<p><strong>Setup LLVM</strong> - Create context, module, builder</p>
</li>
<li>
<p><strong>Create wrapper function</strong> - We need a function to call, so we create <code>__jit</code> with signature <code>() -&gt; i64</code></p>
</li>
<li>
<p><strong>Compile AST</strong> - <code>recursive_builder</code> walks the tree:</p>
<ul>
<li>Compile <code>Int(1)</code> → creates i64 constant <code>1</code></li>
<li>Compile <code>Int(2)</code> → creates i64 constant <code>2</code></li>
<li>Compile <code>Add</code> → creates <code>add i64 1, 2</code> instruction, returns the result</li>
</ul>
</li>
<li>
<p><strong>Return result</strong> - <code>build_return</code> emits a <code>ret</code> instruction with our computed value</p>
</li>
<li>
<p><strong>JIT compile</strong> - LLVM turns our IR into native machine code</p>
</li>
<li>
<p><strong>Execute</strong> - Call the function, get <code>3</code></p>
</li>
</ol>
<h3 id="why-this-matters"><a class="header" href="#why-this-matters">Why This Matters</a></h3>
<p>The recursive builder pattern scales to any expression, no matter how complex:</p>
<pre><code>-((1 + 2) * (3 - 4))
</code></pre>
<p>This parses to a nested tree, and <code>recursive_builder</code> handles each level automatically. Each call compiles its children first, then emits its own instruction using those children as operands.</p>
<p>This is the foundation of every LLVM-based compiler. Rust, Swift, Julia - they all use this pattern (with many more node types and optimizations).</p>
<h3 id="testing"><a class="header" href="#testing">Testing</a></h3>
<pre><code class="language-rust ignore">assert_eq!(Jit::from_source("1 + 2").unwrap(), 3)</code></pre>
<p>Run tests locally:</p>
<pre><code class="language-bash">cargo test jit --tests
</code></pre>
<p>In the <a href="./vm.html">next section</a>, we’ll see an alternative approach: compiling to bytecode for a virtual machine, which trades some speed for portability.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../01_calculator/basic_llvm.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../01_calculator/vm.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../01_calculator/basic_llvm.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../01_calculator/vm.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/force-theme.js"></script>



    </div>
    </body>
</html>
